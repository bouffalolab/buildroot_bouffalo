From 3f8e9a0cdb9d02a6c9a8f49087e5a9e3f303519c Mon Sep 17 00:00:00 2001
From: qhli <qhli@bouffalolab.com>
Date: Fri, 20 Oct 2023 14:33:56 +0800
Subject: [PATCH] NEW: add bl808 sflash driver

	1. Add bl808 sflash driver and register a mtd device named nor0.
	2. Load/store environment variables from/to flash in the first place.
	3. Add configs/sipeed_m1s_dock_defconfig.

Signed-off-by: qhli <qhli@bouffalolab.com>
---
 board/bflb/bl808/Makefile         |    1 +
 board/bflb/bl808/bflb_flash.c     | 1385 +++++++++++++++++++++++++++++
 board/bflb/bl808/bflb_flash.h     | 1160 ++++++++++++++++++++++++
 configs/sipeed_m1s_dock_defconfig |   54 ++
 4 files changed, 2600 insertions(+)
 create mode 100644 board/bflb/bl808/bflb_flash.c
 create mode 100644 board/bflb/bl808/bflb_flash.h
 create mode 100644 configs/sipeed_m1s_dock_defconfig

diff --git a/board/bflb/bl808/Makefile b/board/bflb/bl808/Makefile
index 70cd7a8e56..c3771be93e 100644
--- a/board/bflb/bl808/Makefile
+++ b/board/bflb/bl808/Makefile
@@ -1,3 +1,4 @@
 # SPDX-License-Identifier: GPL-2.0+
 
 obj-y += board.o
+obj-y += bflb_flash.o
diff --git a/board/bflb/bl808/bflb_flash.c b/board/bflb/bl808/bflb_flash.c
new file mode 100644
index 0000000000..ffac099388
--- /dev/null
+++ b/board/bflb/bl808/bflb_flash.c
@@ -0,0 +1,1385 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (c) Bouffalo Lab
+ *
+ */
+
+#include <stdio.h>
+#include <stdint.h>
+#include <stddef.h>
+#include <errno.h>
+#include <common.h>
+#include <flash.h>
+#include <asm/io.h>
+#include <mtd.h>
+#include <linux/delay.h>
+#include "bflb_flash.h"
+
+#define BFLB_FLASH_ID       0x300
+#define BFLB_FLASH_SIZE     (16 << 20)
+#define BFLB_SYS_FLASH_BASE (0x58000000UL)
+
+flash_info_t flash_info[CONFIG_SYS_MAX_FLASH_BANKS];
+
+static spi_flash_cfg_type g_flash_cfg = {
+	.reset_c_read_cmd = 0xff,
+	.reset_c_read_cmd_size = 3,
+	.mid = 0xef,
+
+	.de_burst_wrap_cmd = 0x77,
+	.de_burst_wrap_cmd_dmy_clk = 0x3,
+	.de_burst_wrap_data_mode = SF_CTRL_DATA_4_LINES,
+	.de_burst_wrap_data = 0xF0,
+
+	/* reg */
+	.write_enable_cmd = 0x06,
+	.wr_enable_index = 0x00,
+	.wr_enable_bit = 0x01,
+	.wr_enable_read_reg_len = 0x01,
+
+	.qe_index = 1,
+	.qe_bit = 0x01,
+	.qe_write_reg_len = 0x01,
+	.qe_read_reg_len = 0x1,
+
+	.busy_index = 0,
+	.busy_bit = 0x00,
+	.busy_read_reg_len = 0x1,
+	.release_powerdown = 0xab,
+
+	.read_reg_cmd[0] = 0x05,
+	.read_reg_cmd[1] = 0x35,
+	.write_reg_cmd[0] = 0x01,
+	.write_reg_cmd[1] = 0x31,
+
+	.fast_read_qio_cmd = 0xeb,
+	.fr_qio_dmy_clk = 16 / 8,
+	.c_read_support = 0,
+	.c_read_mode = 0xFF,
+
+	.burst_wrap_cmd = 0x77,
+	.burst_wrap_cmd_dmy_clk = 0x3,
+	.burst_wrap_data_mode = SF_CTRL_DATA_4_LINES,
+	.burst_wrap_data = 0x40,
+	/* erase */
+	.chip_erase_cmd = 0xc7,
+	.sector_erase_cmd = 0x20,
+	.blk32_erase_cmd = 0x52,
+	.blk64_erase_cmd = 0xd8,
+	/* write */
+	.page_program_cmd = 0x02,
+	.qpage_program_cmd = 0x32,
+	.qpp_addr_mode = SF_CTRL_ADDR_1_LINE,
+
+	.io_mode = SF_CTRL_QIO_MODE,
+	.clk_delay = 1,
+	.clk_invert = 0x3f,
+
+	.reset_en_cmd = 0x66,
+	.reset_cmd = 0x99,
+	.c_rexit = 0xff,
+	.wr_enable_write_reg_len = 0x00,
+
+	/* id */
+	.jedec_id_cmd = 0x9f,
+	.jedec_id_cmd_dmy_clk = 0,
+	.enter_32bits_addr_cmd = 0xb7,
+	.exit_32bits_addr_cmd = 0xe9,
+	.sector_size = 4,
+	.page_size = 256,
+
+	/* read */
+	.fast_read_cmd = 0x0b,
+	.fr_dmy_clk = 8 / 8,
+	.qpi_fast_read_cmd = 0x0b,
+	.qpi_fr_dmy_clk = 8 / 8,
+	.fast_read_do_cmd = 0x3b,
+	.fr_do_dmy_clk = 8 / 8,
+	.fast_read_dio_cmd = 0xbb,
+	.fr_dio_dmy_clk = 0,
+	.fast_read_qo_cmd = 0x6b,
+	.fr_qo_dmy_clk = 8 / 8,
+
+	.qpi_fast_read_qio_cmd = 0xeb,
+	.qpi_fr_qio_dmy_clk = 16 / 8,
+	.qpi_page_program_cmd = 0x02,
+	.write_vreg_enable_cmd = 0x50,
+
+	/* qpi mode */
+	.enter_qpi = 0x38,
+	.exit_qpi = 0xff,
+
+	/* AC */
+	.time_e_sector = 400,
+	.time_e_32k = 1600,
+	.time_e_64k = 2000,
+	.time_page_pgm = 5,
+	.time_ce = 33 * 1000,
+	.pd_delay = 3,
+	.qe_data = 0,
+};
+
+static inline u32 getreg32(const u32 addr)
+{
+	void * __iomem io_addr = (void *)(unsigned long)addr;
+
+	return readl(io_addr);
+}
+
+static inline void putreg32(const u32 v, const u32 addr)
+{
+	void * __iomem io_addr = (void *)(unsigned long)addr;
+
+	writel(v, io_addr);
+}
+
+static void bflb_sf_ctrl_32bits_addr_en(u8 en32_bits_addr)
+{
+	u32 reg_base = 0;
+	u32 regval = 0;
+
+	reg_base = BFLB_SF_CTRL_BASE;
+	regval = getreg32(reg_base + SF_CTRL_0_OFFSET);
+	if (en32_bits_addr)
+		regval |= SF_CTRL_SF_IF_32B_ADR_EN;
+	else
+		regval &= ~SF_CTRL_SF_IF_32B_ADR_EN;
+	putreg32(regval, reg_base + SF_CTRL_0_OFFSET);
+}
+
+static u8 bflb_sf_ctrl_get_busy_state(void)
+{
+	u32 regval = 0;
+	u32 cmd_offset = 0;
+
+	cmd_offset = BFLB_SF_CTRL_BASE + SF_CTRL_IF1_SAHB_OFFSET;
+	regval = getreg32(cmd_offset + SF_CTRL_IF_SAHB_0_OFFSET);
+	if (regval & SF_CTRL_IF_BUSY)
+		return 1;
+
+	return 0;
+}
+
+static void bflb_sf_ctrl_set_owner(u8 owner)
+{
+	u32 reg_base = 0;
+	u32 regval = 0;
+	u32 time_out = 0;
+
+	reg_base = BFLB_SF_CTRL_BASE;
+	time_out = SF_CTRL_BUSY_STATE_TIMEOUT;
+
+	while (bflb_sf_ctrl_get_busy_state()) {
+		time_out--;
+
+		if (time_out == 0)
+			return;
+	}
+
+	regval = getreg32(reg_base + SF_CTRL_1_OFFSET);
+	/* set owner */
+	if (owner)
+		regval |= SF_CTRL_SF_IF_FN_SEL;
+	else
+		regval &= ~SF_CTRL_SF_IF_FN_SEL;
+
+	/* set iahb to flash interface */
+	if (owner == SF_CTRL_OWNER_IAHB)
+		regval |= SF_CTRL_SF_AHB2SIF_EN;
+	else
+		regval &= ~SF_CTRL_SF_AHB2SIF_EN;
+
+	putreg32(regval, reg_base + SF_CTRL_1_OFFSET);
+}
+
+static void bflb_sf_ctrl_aes_disable(void)
+{
+	u32 reg_base = 0;
+	u32 regval = 0;
+
+	reg_base = BFLB_SF_CTRL_BASE;
+	regval = getreg32(reg_base + SF_CTRL_SF_AES_OFFSET);
+	regval &= ~SF_CTRL_SF_AES_EN;
+	putreg32(regval, reg_base + SF_CTRL_SF_AES_OFFSET);
+}
+
+static u8 bflb_sf_ctrl_is_aes_enable(void)
+{
+	u32 reg_base = 0;
+	u32 regval = 0;
+
+	reg_base = BFLB_SF_CTRL_BASE;
+	regval = getreg32(reg_base + SF_CTRL_SF_AES_OFFSET);
+	if (regval & SF_CTRL_SF_AES_EN)
+		return 1;
+
+	return 0;
+}
+
+static void bflb_sf_ctrl_aes_enable(void)
+{
+	u32 reg_base = 0;
+	u32 regval = 0;
+
+	reg_base = BFLB_SF_CTRL_BASE;
+	regval = getreg32(reg_base + SF_CTRL_SF_AES_OFFSET);
+	regval |= SF_CTRL_SF_AES_EN;
+	putreg32(regval, reg_base + SF_CTRL_SF_AES_OFFSET);
+}
+
+static void bflb_sf_ctrl_set_flash_image_offset(u32 offset, u8 group, u8 bank)
+{
+	u32 reg_base = 0;
+
+	reg_base = BFLB_SF_CTRL_BASE;
+	if (bank == SF_CTRL_FLASH_BANK0) {
+		if (group)
+			putreg32(offset, reg_base + SF_CTRL_SF_ID1_OFFSET_OFFSET);
+		else
+			putreg32(offset, reg_base + SF_CTRL_SF_ID0_OFFSET_OFFSET);
+	}
+}
+
+static u32 bflb_sf_ctrl_get_flash_image_offset(u8 group, u8 bank)
+{
+	u32 reg_base = 0;
+	u32 regval = 0;
+
+	reg_base = BFLB_SF_CTRL_BASE;
+	regval = getreg32(reg_base + SF_CTRL_SF_ID0_OFFSET_OFFSET);
+	return regval;
+}
+
+static void bflb_sf_ctrl_sendcmd(struct sf_ctrl_cmd_cfg_type *cfg)
+{
+	u32 reg_base = 0;
+	u32 regval = 0;
+	u32 time_out = 0;
+	u32 cmd_offset = 0;
+
+	reg_base = BFLB_SF_CTRL_BASE;
+	time_out = SF_CTRL_BUSY_STATE_TIMEOUT;
+
+	while (bflb_sf_ctrl_get_busy_state()) {
+		time_out--;
+
+		if (time_out == 0)
+			return;
+	}
+
+	regval = getreg32(reg_base + SF_CTRL_1_OFFSET);
+	if (regval & SF_CTRL_SF_IF_FN_SEL)
+		return;
+	cmd_offset = reg_base + SF_CTRL_IF1_SAHB_OFFSET;
+
+	/* clear trigger */
+	regval = getreg32(cmd_offset + SF_CTRL_IF_SAHB_0_OFFSET);
+	regval &= ~SF_CTRL_IF_0_TRIG;
+	putreg32(regval, cmd_offset + SF_CTRL_IF_SAHB_0_OFFSET);
+
+	/* copy command buffer */
+	putreg32(cfg->cmd_buf[0], cmd_offset + SF_CTRL_IF_SAHB_1_OFFSET);
+	putreg32(cfg->cmd_buf[1], cmd_offset + SF_CTRL_IF_SAHB_2_OFFSET);
+
+	/* configure SPI and IO mode */
+	regval = getreg32(cmd_offset + SF_CTRL_IF_SAHB_0_OFFSET);
+	if (cfg->cmd_mode == SF_CTRL_CMD_1_LINE)
+		regval &= ~SF_CTRL_IF_0_QPI_MODE_EN;
+	else
+		regval |= SF_CTRL_IF_0_QPI_MODE_EN;
+
+	regval &= ~SF_CTRL_IF_0_SPI_MODE_MASK;
+	if (cfg->addr_mode == SF_CTRL_ADDR_1_LINE) {
+		if (cfg->data_mode == SF_CTRL_DATA_1_LINE)
+			regval |= (SF_CTRL_NIO_MODE << SF_CTRL_IF_0_SPI_MODE_SHIFT);
+		else if (cfg->data_mode == SF_CTRL_DATA_2_LINES)
+			regval |= (SF_CTRL_DO_MODE << SF_CTRL_IF_0_SPI_MODE_SHIFT);
+		else if (cfg->data_mode == SF_CTRL_DATA_4_LINES)
+			regval |= (SF_CTRL_QO_MODE << SF_CTRL_IF_0_SPI_MODE_SHIFT);
+	} else if (cfg->addr_mode == SF_CTRL_ADDR_2_LINES) {
+		regval |= (SF_CTRL_DIO_MODE << SF_CTRL_IF_0_SPI_MODE_SHIFT);
+	} else if (cfg->addr_mode == SF_CTRL_ADDR_4_LINES) {
+		regval |= (SF_CTRL_QIO_MODE << SF_CTRL_IF_0_SPI_MODE_SHIFT);
+	}
+
+	/* configure cmd */
+	regval |= SF_CTRL_IF_0_CMD_EN;
+	regval &= ~SF_CTRL_IF_0_CMD_BYTE_MASK;
+
+	/* configure address */
+	regval &= ~SF_CTRL_IF_0_ADR_BYTE_MASK;
+	if (cfg->addr_size != 0) {
+		regval |= SF_CTRL_IF_0_ADR_EN;
+		regval |= ((cfg->addr_size - 1) << SF_CTRL_IF_0_ADR_BYTE_SHIFT);
+	} else {
+		regval &= ~SF_CTRL_IF_0_ADR_EN;
+	}
+
+	/* configure dummy */
+	regval &= ~SF_CTRL_IF_0_DMY_BYTE_MASK;
+	if (cfg->dummy_clks != 0) {
+		regval |= SF_CTRL_IF_0_DMY_EN;
+		regval |= ((cfg->dummy_clks - 1) << SF_CTRL_IF_0_DMY_BYTE_SHIFT);
+	} else {
+		regval &= ~SF_CTRL_IF_0_DMY_EN;
+	}
+
+	/* configure data */
+	regval &= ~SF_CTRL_IF_0_DAT_BYTE_MASK;
+	if (cfg->nb_data != 0) {
+		regval |= SF_CTRL_IF_0_DAT_EN;
+		regval |= ((cfg->nb_data - 1) << SF_CTRL_IF_0_DAT_BYTE_SHIFT);
+	} else {
+		regval &= ~SF_CTRL_IF_0_DAT_EN;
+	}
+
+	/* set read write flag */
+	if (cfg->rw_flag)
+		regval |= SF_CTRL_IF_0_DAT_RW;
+	else
+		regval &= ~SF_CTRL_IF_0_DAT_RW;
+	putreg32(regval, cmd_offset + SF_CTRL_IF_SAHB_0_OFFSET);
+
+	/* trigger */
+	regval |= SF_CTRL_IF_0_TRIG;
+	putreg32(regval, cmd_offset + SF_CTRL_IF_SAHB_0_OFFSET);
+
+	time_out = SF_CTRL_BUSY_STATE_TIMEOUT;
+	while (bflb_sf_ctrl_get_busy_state()) {
+		time_out--;
+
+		if (time_out == 0)
+			return;
+	}
+}
+
+static void bflb_sf_ctrl_xip_set(struct sf_ctrl_cmd_cfg_type *cfg,
+				 u8 cmd_valid)
+{
+	u32 reg_base = 0;
+	u32 regval = 0;
+	u32 time_out = 0;
+
+	reg_base = BFLB_SF_CTRL_BASE;
+	time_out = SF_CTRL_BUSY_STATE_TIMEOUT;
+
+	while (bflb_sf_ctrl_get_busy_state()) {
+		time_out--;
+
+		if (time_out == 0)
+			return;
+	}
+
+	regval = getreg32(reg_base + SF_CTRL_1_OFFSET);
+	if ((regval & SF_CTRL_SF_IF_FN_SEL) == 0)
+		return;
+
+	/* copy command buffer */
+	putreg32(cfg->cmd_buf[0], reg_base + SF_CTRL_SF_IF_IAHB_1_OFFSET);
+	putreg32(cfg->cmd_buf[1], reg_base + SF_CTRL_SF_IF_IAHB_2_OFFSET);
+
+	regval = getreg32(reg_base + SF_CTRL_SF_IF_IAHB_0_OFFSET);
+	/* configure SPI and IO mode*/
+	if (cfg->cmd_mode == SF_CTRL_CMD_1_LINE)
+		regval &= ~SF_CTRL_SF_IF_1_QPI_MODE_EN;
+	else
+		regval |= SF_CTRL_SF_IF_1_QPI_MODE_EN;
+
+	regval &= ~SF_CTRL_SF_IF_1_SPI_MODE_MASK;
+	if (cfg->addr_mode == SF_CTRL_ADDR_1_LINE) {
+		if (cfg->data_mode == SF_CTRL_DATA_1_LINE)
+			regval |= (SF_CTRL_NIO_MODE << SF_CTRL_SF_IF_1_SPI_MODE_SHIFT);
+		else if (cfg->data_mode == SF_CTRL_DATA_2_LINES)
+			regval |= (SF_CTRL_DO_MODE << SF_CTRL_SF_IF_1_SPI_MODE_SHIFT);
+		else if (cfg->data_mode == SF_CTRL_DATA_4_LINES)
+			regval |= (SF_CTRL_QO_MODE << SF_CTRL_SF_IF_1_SPI_MODE_SHIFT);
+	} else if (cfg->addr_mode == SF_CTRL_ADDR_2_LINES) {
+		regval |= (SF_CTRL_DIO_MODE << SF_CTRL_SF_IF_1_SPI_MODE_SHIFT);
+	} else if (cfg->addr_mode == SF_CTRL_ADDR_4_LINES) {
+		regval |= (SF_CTRL_QIO_MODE << SF_CTRL_SF_IF_1_SPI_MODE_SHIFT);
+	}
+
+	regval &= ~SF_CTRL_SF_IF_1_CMD_BYTE_MASK;
+	if (cmd_valid)
+		regval |= SF_CTRL_SF_IF_1_CMD_EN;
+	else
+		regval &= ~SF_CTRL_SF_IF_1_CMD_EN;
+
+	/* configure address */
+	regval &= ~SF_CTRL_SF_IF_1_ADR_BYTE_MASK;
+	if (cfg->addr_size != 0) {
+		regval |= SF_CTRL_SF_IF_1_ADR_EN;
+		regval |= ((cfg->addr_size - 1) << SF_CTRL_SF_IF_1_ADR_BYTE_SHIFT);
+	} else {
+		regval &= ~SF_CTRL_SF_IF_1_ADR_EN;
+	}
+
+	/* configure dummy */
+	regval &= ~SF_CTRL_SF_IF_1_DMY_BYTE_MASK;
+	if (cfg->dummy_clks != 0) {
+		regval |= SF_CTRL_SF_IF_1_DMY_EN;
+		regval |= ((cfg->dummy_clks - 1) << SF_CTRL_SF_IF_1_DMY_BYTE_SHIFT);
+	} else {
+		regval &= ~SF_CTRL_SF_IF_1_DMY_EN;
+	}
+
+	/* configure data */
+	if (cfg->nb_data != 0)
+		regval |= SF_CTRL_SF_IF_1_DAT_EN;
+	else
+		regval &= ~SF_CTRL_SF_IF_1_DAT_EN;
+
+	/* set read write flag */
+	if (cfg->rw_flag)
+		regval |= SF_CTRL_SF_IF_1_DAT_RW;
+	else
+		regval &= ~SF_CTRL_SF_IF_1_DAT_RW;
+	putreg32(regval, reg_base + SF_CTRL_SF_IF_IAHB_0_OFFSET);
+}
+
+static int bflb_sflash_read_reg(spi_flash_cfg_type *flash_cfg, u8 reg_index,
+				u8 *reg_value, u8 reg_len)
+{
+	u8 *const flash_ctrl_buf = (u8 *)BFLB_SF_CTRL_BUF_BASE;
+	struct sf_ctrl_cmd_cfg_type flash_cmd;
+	u32 cnt = 0;
+
+	memset(&flash_cmd, 0, sizeof(flash_cmd));
+	flash_cmd.cmd_buf[0] = flash_cfg->read_reg_cmd[reg_index] << 24;
+	flash_cmd.rw_flag = SF_CTRL_READ;
+	flash_cmd.nb_data = reg_len;
+	bflb_sf_ctrl_sendcmd(&flash_cmd);
+
+	while (bflb_sf_ctrl_get_busy_state()) {
+		udelay(1);
+		cnt++;
+
+		if (cnt > 1000)
+			return -1;
+	}
+
+	memcpy(reg_value, flash_ctrl_buf, reg_len);
+	return 0;
+}
+
+static int bflb_sflash_busy(spi_flash_cfg_type *flash_cfg)
+{
+	u32 stat = 0;
+
+	bflb_sflash_read_reg(flash_cfg, flash_cfg->busy_index, (u8 *)&stat,
+			     flash_cfg->busy_read_reg_len);
+	if ((stat & (1 << flash_cfg->busy_bit)) == 0)
+		return 0;
+
+	return 1;
+}
+
+static int bflb_sflash_write_reg(spi_flash_cfg_type *flash_cfg,
+				 u8 reg_index, u8 *reg_value, u8 reg_len)
+{
+	u8 *const flash_ctrl_buf = (u8 *)BFLB_SF_CTRL_BUF_BASE;
+	u32 cnt = 0;
+	struct sf_ctrl_cmd_cfg_type flash_cmd;
+
+	memset(&flash_cmd, 0, sizeof(flash_cmd));
+	memcpy(flash_ctrl_buf, reg_value, reg_len);
+
+	flash_cmd.cmd_buf[0] = (flash_cfg->write_reg_cmd[reg_index]) << 24;
+	flash_cmd.rw_flag = SF_CTRL_WRITE;
+	flash_cmd.nb_data = reg_len;
+
+	bflb_sf_ctrl_sendcmd(&flash_cmd);
+
+	/* take 40ms for tw(write status register) as default */
+	while (bflb_sflash_busy(flash_cfg)) {
+		udelay(100);
+		cnt++;
+
+		if (cnt > 400)
+			return -1;
+	}
+
+	return 0;
+}
+
+static int bflb_sflash_write_enable(spi_flash_cfg_type *flash_cfg)
+{
+	u32 stat = 0;
+	struct sf_ctrl_cmd_cfg_type flash_cmd;
+
+	memset(&flash_cmd, 0, sizeof(flash_cmd));
+	/* write enable */
+	flash_cmd.cmd_buf[0] = (flash_cfg->write_enable_cmd) << 24;
+	/* rw_flag don't care */
+	flash_cmd.rw_flag = SF_CTRL_READ;
+	bflb_sf_ctrl_sendcmd(&flash_cmd);
+
+	bflb_sflash_read_reg(flash_cfg, flash_cfg->wr_enable_index,
+			     (u8 *)&stat, flash_cfg->wr_enable_read_reg_len);
+	if ((stat & (1 << flash_cfg->wr_enable_bit)) != 0)
+		return 0;
+
+	return -1;
+}
+
+static int bflb_sflash_qspi_enable(spi_flash_cfg_type *flash_cfg)
+{
+	u32 stat = 0, ret = 0;
+
+	if (flash_cfg->qe_read_reg_len == 0) {
+		ret = bflb_sflash_write_enable(flash_cfg);
+
+		if (ret)
+			return -1;
+
+		bflb_sflash_write_reg(flash_cfg, flash_cfg->qe_index,
+				      (u8 *)&stat, flash_cfg->qe_write_reg_len);
+		return 0;
+	}
+
+	bflb_sflash_read_reg(flash_cfg, flash_cfg->qe_index, (u8 *)&stat,
+			     flash_cfg->qe_read_reg_len);
+	if (flash_cfg->qe_data == 0) {
+		if ((stat & (1 << flash_cfg->qe_bit)) != 0)
+			return 0;
+	} else {
+		if (((stat >> (flash_cfg->qe_bit & 0x08)) & 0xff) == flash_cfg->qe_data)
+			return 0;
+	}
+
+	if (flash_cfg->qe_write_reg_len != 1) {
+		/* this is  read r0, read r1 write r0, r1 case*/
+		bflb_sflash_read_reg(flash_cfg, 0, (u8 *)&stat, 1);
+		bflb_sflash_read_reg(flash_cfg, 1, ((u8 *)&stat) + 1, 1);
+
+		if (flash_cfg->qe_data == 0) {
+			stat |= (1 << (flash_cfg->qe_bit + 8 * flash_cfg->qe_index));
+		} else {
+			stat = stat & (~(0xff << (8 * flash_cfg->qe_index)));
+			stat |= (flash_cfg->qe_data << (8 * flash_cfg->qe_index));
+		}
+	} else {
+		if (flash_cfg->qe_data == 0)
+			stat |= (1 << (flash_cfg->qe_bit % 8));
+		else
+			stat = flash_cfg->qe_data;
+	}
+
+	ret = bflb_sflash_write_enable(flash_cfg);
+	if (ret)
+		return -1;
+
+	bflb_sflash_write_reg(flash_cfg, flash_cfg->qe_index, (u8 *)&stat,
+			      flash_cfg->qe_write_reg_len);
+	bflb_sflash_read_reg(flash_cfg, flash_cfg->qe_index, (u8 *)&stat,
+			     flash_cfg->qe_read_reg_len);
+	if (flash_cfg->qe_data == 0) {
+		if ((stat & (1 << flash_cfg->qe_bit)) != 0)
+			return 0;
+	} else {
+		if (((stat >> (flash_cfg->qe_bit & 0x08)) & 0xff) == flash_cfg->qe_data)
+			return 0;
+	}
+
+	return -1;
+}
+
+static int bflb_sflash_do_erase(spi_flash_cfg_type *flash_cfg, u32 addr,
+				u8 cmd, u32 timeout)
+{
+	int stat;
+	u32 cnt = 0;
+	u8 is_32bits_addr = 0;
+	struct sf_ctrl_cmd_cfg_type flash_cmd;
+
+	stat = bflb_sflash_write_enable(flash_cfg);
+	if (stat)
+		return stat;
+
+	memset(&flash_cmd, 0, sizeof(flash_cmd));
+	is_32bits_addr = flash_cfg->io_mode & 0x20;
+	/* rw_flag don't care */
+	flash_cmd.rw_flag = SF_CTRL_READ;
+	flash_cmd.addr_size = 3;
+
+	if (is_32bits_addr > 0) {
+		flash_cmd.addr_size++;
+		flash_cmd.cmd_buf[0] = (cmd << 24) | (addr >> 8);
+		flash_cmd.cmd_buf[1] = addr << 24;
+	} else {
+		flash_cmd.cmd_buf[0] = (cmd << 24) | addr;
+	}
+
+	bflb_sf_ctrl_sendcmd(&flash_cmd);
+	while (bflb_sflash_busy(flash_cfg)) {
+		udelay(500);
+		cnt++;
+
+		if (cnt > timeout * 3)
+			return -1;
+	}
+
+	return 0;
+}
+
+static int bflb_sflash_erase(spi_flash_cfg_type *flash_cfg, u32 start_addr,
+			     u32 end_addr)
+{
+	u8 ret = 0;
+	u32 len = 0;
+	u32 erase_len = 0;
+
+	if (start_addr > end_addr)
+		return -1;
+
+	while (start_addr <= end_addr) {
+		len = end_addr - start_addr + 1;
+
+		if (flash_cfg->blk64_erase_cmd != BFLB_SPIFLASH_CMD_INVALID &&
+		    (start_addr & (BFLB_SPIFLASH_BLK64K_SIZE - 1)) == 0 &&
+			 len > (BFLB_SPIFLASH_BLK64K_SIZE - flash_cfg->sector_size * 1024)) {
+			/* 64K margin address, and length > 64K-sector size, erase one first */
+			ret = bflb_sflash_do_erase(flash_cfg, start_addr,
+						   flash_cfg->blk64_erase_cmd, flash_cfg->time_e_64k);
+			erase_len = BFLB_SPIFLASH_BLK64K_SIZE;
+		} else if (flash_cfg->blk32_erase_cmd != BFLB_SPIFLASH_CMD_INVALID &&
+				(start_addr & (BFLB_SPIFLASH_BLK32K_SIZE - 1)) == 0 &&
+				len > (BFLB_SPIFLASH_BLK32K_SIZE - flash_cfg->sector_size * 1024)) {
+			/* 32K margin address, and length > 32K-sector size, erase one first */
+			ret = bflb_sflash_do_erase(flash_cfg, start_addr,
+						   flash_cfg->blk32_erase_cmd, flash_cfg->time_e_32k);
+			erase_len = BFLB_SPIFLASH_BLK32K_SIZE;
+		} else {
+			/* sector erase */
+			start_addr = ((start_addr) & (~(flash_cfg->sector_size * 1024 - 1)));
+			ret = bflb_sflash_do_erase(flash_cfg, start_addr,
+						   flash_cfg->sector_erase_cmd, flash_cfg->time_e_sector);
+			erase_len = flash_cfg->sector_size * 1024;
+		}
+
+		start_addr += erase_len;
+
+		if (ret != 0)
+			return -1;
+	}
+
+	return 0;
+}
+
+static void bflb_sflash_set_burst_wrap(spi_flash_cfg_type *flash_cfg)
+{
+	u8 *const flash_ctrl_buf = (u8 *)BFLB_SF_CTRL_BUF_BASE;
+	u8 cmd = 0, dummy_clks = 0;
+	u32 wrap_data = 0;
+	struct sf_ctrl_cmd_cfg_type flash_cmd;
+
+	/* disable burst wrap, just return */
+	if (((flash_cfg->io_mode >> 4) & 0x01) == 1)
+		return;
+
+	memset(&flash_cmd, 0, sizeof(flash_cmd));
+	flash_cmd.addr_mode = flash_cfg->burst_wrap_data_mode;
+	flash_cmd.data_mode = flash_cfg->burst_wrap_data_mode;
+	dummy_clks = flash_cfg->burst_wrap_cmd_dmy_clk;
+	cmd = flash_cfg->burst_wrap_cmd;
+	wrap_data = flash_cfg->burst_wrap_data;
+	memcpy((u32 *)flash_ctrl_buf, &wrap_data, 4);
+	flash_cmd.cmd_buf[0] = (cmd << 24);
+	flash_cmd.rw_flag = SF_CTRL_WRITE;
+	flash_cmd.dummy_clks = dummy_clks;
+	flash_cmd.nb_data = 1;
+
+	bflb_sf_ctrl_sendcmd(&flash_cmd);
+}
+
+static void bflb_sflash_disable_burst_wrap(spi_flash_cfg_type *flash_cfg)
+{
+	u8 *const flash_ctrl_buf = (u8 *)BFLB_SF_CTRL_BUF_BASE;
+	u8 cmd = 0, dummy_clks = 0;
+	u32 wrap_data = 0;
+	struct sf_ctrl_cmd_cfg_type flash_cmd;
+
+	memset(&flash_cmd, 0, sizeof(flash_cmd));
+	flash_cmd.addr_mode = flash_cfg->de_burst_wrap_data_mode;
+	flash_cmd.data_mode = flash_cfg->de_burst_wrap_data_mode;
+	dummy_clks = flash_cfg->de_burst_wrap_cmd_dmy_clk;
+	cmd = flash_cfg->de_burst_wrap_cmd;
+	wrap_data = flash_cfg->de_burst_wrap_data;
+	memcpy((u32 *)flash_ctrl_buf, &wrap_data, 4);
+	flash_cmd.cmd_buf[0] = (cmd << 24);
+	flash_cmd.rw_flag = SF_CTRL_WRITE;
+	flash_cmd.dummy_clks = dummy_clks;
+	flash_cmd.nb_data = 1;
+	bflb_sf_ctrl_sendcmd(&flash_cmd);
+}
+
+static int bflb_sflash_set_32bits_addr_mode(spi_flash_cfg_type *flash_cfg,
+					    u8 en_32bits_addr)
+{
+	u8 cmd = 0;
+	struct sf_ctrl_cmd_cfg_type flash_cmd;
+
+	if ((flash_cfg->io_mode & 0x20) == 0)
+		return -1;
+
+	memset(&flash_cmd, 0, sizeof(flash_cmd));
+	bflb_sf_ctrl_32bits_addr_en(en_32bits_addr);
+
+	if (en_32bits_addr)
+		cmd = flash_cfg->enter_32bits_addr_cmd;
+	else
+		cmd = flash_cfg->exit_32bits_addr_cmd;
+
+	flash_cmd.cmd_buf[0] = (cmd << 24);
+	/* rw_flag don't care */
+	flash_cmd.rw_flag = SF_CTRL_READ;
+	bflb_sf_ctrl_sendcmd(&flash_cmd);
+	return 0;
+}
+
+static void bflb_sflash_reset_continue_read(spi_flash_cfg_type *flash_cfg)
+{
+	struct sf_ctrl_cmd_cfg_type flash_cmd;
+
+	memset(&flash_cmd, 0, sizeof(flash_cmd));
+	/* reset continuous read */
+	memset(&flash_cmd.cmd_buf[0], flash_cfg->reset_c_read_cmd, 4);
+	/* rw_flag don't care */
+	flash_cmd.rw_flag = SF_CTRL_READ;
+	flash_cmd.addr_size = flash_cfg->reset_c_read_cmd_size;
+	bflb_sf_ctrl_sendcmd(&flash_cmd);
+}
+
+static int bflb_sflash_set_xip_cfg(spi_flash_cfg_type *flash_cfg, u8 io_mode,
+				   u8 cont_read, u32 addr, u32 len, u8 bank)
+{
+	u8 cmd = 0, dummy_clks = 0;
+	struct sf_ctrl_cmd_cfg_type flash_cmd;
+	u8 cmd_valid = 1;
+	u8 no_read_mode_cfg = 0;
+	u8 c_read_support = 0;
+	u8 is_32bits_addr = 0;
+
+	memset(&flash_cmd, 0, sizeof(flash_cmd));
+	bflb_sf_ctrl_set_owner(SF_CTRL_OWNER_IAHB);
+
+	if (io_mode == SF_CTRL_NIO_MODE) {
+		cmd = flash_cfg->fast_read_cmd;
+		dummy_clks = flash_cfg->fr_dmy_clk;
+	} else if (io_mode == SF_CTRL_DO_MODE) {
+		flash_cmd.data_mode = SF_CTRL_DATA_2_LINES;
+		cmd = flash_cfg->fast_read_do_cmd;
+		dummy_clks = flash_cfg->fr_do_dmy_clk;
+	} else if (io_mode == SF_CTRL_DIO_MODE) {
+		flash_cmd.addr_mode = SF_CTRL_ADDR_2_LINES;
+		flash_cmd.data_mode = SF_CTRL_DATA_2_LINES;
+		cmd = flash_cfg->fast_read_dio_cmd;
+		dummy_clks = flash_cfg->fr_dio_dmy_clk;
+	} else if (io_mode == SF_CTRL_QO_MODE) {
+		flash_cmd.data_mode = SF_CTRL_DATA_4_LINES;
+		cmd = flash_cfg->fast_read_qo_cmd;
+		dummy_clks = flash_cfg->fr_qo_dmy_clk;
+	} else if (io_mode == SF_CTRL_QIO_MODE) {
+		flash_cmd.addr_mode = SF_CTRL_ADDR_4_LINES;
+		flash_cmd.data_mode = SF_CTRL_DATA_4_LINES;
+		cmd = flash_cfg->fast_read_qio_cmd;
+		dummy_clks = flash_cfg->fr_qio_dmy_clk;
+	} else {
+		return -1;
+	}
+
+	is_32bits_addr = (flash_cfg->io_mode & 0x20);
+	/* prepare command */
+	flash_cmd.rw_flag = SF_CTRL_READ;
+	flash_cmd.addr_size = 3;
+
+	if (is_32bits_addr > 0) {
+		flash_cmd.addr_size++;
+		flash_cmd.cmd_buf[0] = (cmd << 24) | (addr >> 8);
+		flash_cmd.cmd_buf[1] = (addr << 24);
+	} else {
+		flash_cmd.cmd_buf[0] = (cmd << 24) | addr;
+	}
+
+	if (SF_CTRL_QIO_MODE == io_mode || SF_CTRL_DIO_MODE == io_mode) {
+		no_read_mode_cfg = flash_cfg->c_read_support & 0x02;
+		c_read_support = flash_cfg->c_read_support & 0x01;
+
+		if (no_read_mode_cfg == 0) {
+			/* read mode must be set*/
+			if (c_read_support == 0) {
+				/* not support cont read,but we still need set read mode(winbond 80dv)*/
+				if (is_32bits_addr > 0)
+					flash_cmd.cmd_buf[1] |= (flash_cfg->c_read_mode << 16);
+				else
+					flash_cmd.cmd_buf[1] = (flash_cfg->c_read_mode << 24);
+			} else {
+				/* flash support cont read, setting depend on user parameter */
+				if (cont_read) {
+					if (is_32bits_addr > 0) {
+						flash_cmd.cmd_buf[0] = addr;
+						flash_cmd.cmd_buf[1] = (flash_cfg->c_read_mode << 24);
+					} else {
+						flash_cmd.cmd_buf[0] = (addr << 8) | flash_cfg->c_read_mode;
+					}
+
+					cmd_valid = 0;
+				} else {
+					if (is_32bits_addr > 0)
+						flash_cmd.cmd_buf[1] |= ((!flash_cfg->c_read_mode) << 16);
+					else
+						flash_cmd.cmd_buf[1] = ((!flash_cfg->c_read_mode) << 24);
+				}
+			}
+
+			flash_cmd.addr_size++;
+		}
+	}
+
+	flash_cmd.dummy_clks = dummy_clks;
+	flash_cmd.nb_data = len;
+	bflb_sf_ctrl_xip_set(&flash_cmd, cmd_valid);
+	return 0;
+}
+
+static int bflb_sflash_read(spi_flash_cfg_type *flash_cfg, u8 io_mode,
+			    u8 cont_read, u32 addr, u8 *data, u32 len)
+{
+	u8 *const flash_ctrl_buf = (u8 *)BFLB_SF_CTRL_BUF_BASE;
+	u32 cur_len = 0, i = 0;
+	u8 cmd = 0, dummy_clks = 0;
+	u32 timeout = 0;
+	struct sf_ctrl_cmd_cfg_type flash_cmd;
+	u8 no_read_mode_cfg = 0;
+	u8 c_read_support = 0;
+	u8 is_32bits_addr = 0;
+
+	memset(&flash_cmd, 0, sizeof(flash_cmd));
+	if (io_mode == SF_CTRL_NIO_MODE) {
+		cmd = flash_cfg->fast_read_cmd;
+		dummy_clks = flash_cfg->fr_dmy_clk;
+	} else if (io_mode == SF_CTRL_DO_MODE) {
+		flash_cmd.data_mode = SF_CTRL_DATA_2_LINES;
+		cmd = flash_cfg->fast_read_do_cmd;
+		dummy_clks = flash_cfg->fr_do_dmy_clk;
+	} else if (io_mode == SF_CTRL_DIO_MODE) {
+		flash_cmd.addr_mode = SF_CTRL_ADDR_2_LINES;
+		flash_cmd.data_mode = SF_CTRL_DATA_2_LINES;
+		cmd = flash_cfg->fast_read_dio_cmd;
+		dummy_clks = flash_cfg->fr_dio_dmy_clk;
+	} else if (io_mode == SF_CTRL_QO_MODE) {
+		flash_cmd.data_mode = SF_CTRL_DATA_4_LINES;
+		cmd = flash_cfg->fast_read_qo_cmd;
+		dummy_clks = flash_cfg->fr_qo_dmy_clk;
+	} else if (io_mode == SF_CTRL_QIO_MODE) {
+		flash_cmd.addr_mode = SF_CTRL_ADDR_4_LINES;
+		flash_cmd.data_mode = SF_CTRL_DATA_4_LINES;
+		cmd = flash_cfg->fast_read_qio_cmd;
+		dummy_clks = flash_cfg->fr_qio_dmy_clk;
+	} else {
+		return -1;
+	}
+
+	is_32bits_addr = (flash_cfg->io_mode & 0x20);
+	/* prepare command */
+	flash_cmd.rw_flag = SF_CTRL_READ;
+	flash_cmd.addr_size = 3;
+
+	if (is_32bits_addr > 0)
+		flash_cmd.addr_size++;
+
+	if (SF_CTRL_QIO_MODE == io_mode || SF_CTRL_DIO_MODE == io_mode) {
+		no_read_mode_cfg = flash_cfg->c_read_support & 0x02;
+		c_read_support = flash_cfg->c_read_support & 0x01;
+
+		if (no_read_mode_cfg == 0) {
+			/* read mode must be set */
+			if (c_read_support == 0) {
+				/* not support cont read, but we still need set read mode(winbond 80dv) */
+				if (is_32bits_addr > 0)
+					flash_cmd.cmd_buf[1] |= (flash_cfg->c_read_mode << 16);
+				else
+					flash_cmd.cmd_buf[1] = (flash_cfg->c_read_mode << 24);
+			} else {
+				/* flash support cont read, setting depend on user parameter */
+				if (cont_read) {
+					if (is_32bits_addr > 0)
+						flash_cmd.cmd_buf[1] |= (flash_cfg->c_read_mode << 16);
+					else
+						flash_cmd.cmd_buf[1] = (flash_cfg->c_read_mode << 24);
+				} else {
+					if (is_32bits_addr > 0)
+						flash_cmd.cmd_buf[1] |= ((!flash_cfg->c_read_mode) << 16);
+					else
+						flash_cmd.cmd_buf[1] = ((!flash_cfg->c_read_mode) << 24);
+				}
+			}
+
+			flash_cmd.addr_size++;
+		}
+	}
+
+	flash_cmd.dummy_clks = dummy_clks;
+
+	/* read data */
+	for (i = 0; i < len;) {
+		/* prepare command */
+		if (is_32bits_addr > 0) {
+			flash_cmd.cmd_buf[0] = (cmd << 24) | (addr >> 8);
+			flash_cmd.cmd_buf[1] |= (addr << 24);
+		} else {
+			flash_cmd.cmd_buf[0] = (cmd << 24) | (addr);
+		}
+
+		cur_len = len - i;
+
+		if (cur_len >= NOR_FLASH_CTRL_BUF_SIZE) {
+			cur_len = NOR_FLASH_CTRL_BUF_SIZE;
+			flash_cmd.nb_data = cur_len;
+		} else {
+			/* make sf_ctrl word read */
+			flash_cmd.nb_data = ((cur_len + 3) >> 2) << 2;
+		}
+
+		bflb_sf_ctrl_sendcmd(&flash_cmd);
+
+		timeout = SF_CTRL_BUSY_STATE_TIMEOUT;
+		while (bflb_sf_ctrl_get_busy_state()) {
+			timeout--;
+
+			if (timeout == 0)
+				return -2;
+		}
+
+		memcpy(data, flash_ctrl_buf, cur_len);
+
+		addr += cur_len;
+		i += cur_len;
+		data += cur_len;
+	}
+
+	return 0;
+}
+
+static int bflb_sflash_program(spi_flash_cfg_type *flash_cfg, u8 io_mode,
+			       u32 addr, u8 *data, u32 len)
+{
+	u8 *const flash_ctrl_buf = (u8 *)BFLB_SF_CTRL_BUF_BASE;
+	u32 i = 0, cur_len = 0;
+	u32 cnt = 0;
+	int stat = 0;
+	u8 is_32bits_addr = 0;
+	u8 cmd = 0;
+	struct sf_ctrl_cmd_cfg_type flash_cmd;
+
+	memset(&flash_cmd, 0, sizeof(flash_cmd));
+	if (io_mode == SF_CTRL_NIO_MODE || io_mode == SF_CTRL_DO_MODE ||
+	    io_mode == SF_CTRL_DIO_MODE) {
+		cmd = flash_cfg->page_program_cmd;
+	} else if (io_mode == SF_CTRL_QIO_MODE || io_mode == SF_CTRL_QO_MODE) {
+		flash_cmd.addr_mode = flash_cfg->qpp_addr_mode;
+		flash_cmd.data_mode = SF_CTRL_DATA_4_LINES;
+		cmd = flash_cfg->qpage_program_cmd;
+	} else {
+		return -1;
+	}
+
+	is_32bits_addr = (flash_cfg->io_mode & 0x20);
+	/* prepare command */
+	flash_cmd.rw_flag = SF_CTRL_WRITE;
+	flash_cmd.addr_size = 3;
+
+	if (is_32bits_addr > 0)
+		flash_cmd.addr_size++;
+
+	for (i = 0; i < len;) {
+		/* write enable is needed for every program */
+		stat = bflb_sflash_write_enable(flash_cfg);
+
+		if (stat)
+			return stat;
+
+		/* get current programmed length within page size */
+		cur_len = flash_cfg->page_size - addr % flash_cfg->page_size;
+
+		if (cur_len > len - i)
+			cur_len = len - i;
+
+		/* prepare command */
+		memcpy(flash_ctrl_buf, data, cur_len);
+
+		if (is_32bits_addr > 0) {
+			flash_cmd.cmd_buf[0] = (cmd << 24) | (addr >> 8);
+			flash_cmd.cmd_buf[1] = (addr << 24);
+		} else {
+			flash_cmd.cmd_buf[0] = (cmd << 24) | (addr);
+		}
+
+		flash_cmd.nb_data = cur_len;
+
+		bflb_sf_ctrl_sendcmd(&flash_cmd);
+
+		/* adjust address and programmed length */
+		addr += cur_len;
+		i += cur_len;
+		data += cur_len;
+
+		/* wait for write done */
+		cnt = 0;
+
+		while (bflb_sflash_busy(flash_cfg)) {
+			udelay(100);
+			cnt++;
+
+			if (cnt > flash_cfg->time_page_pgm * 20)
+				return -1;
+		}
+	}
+
+	return 0;
+}
+
+static int bflb_xip_sflash_state_save(spi_flash_cfg_type *p_flash_cfg,
+				      u32 *offset, u8 group, u8 bank)
+{
+	/* xip_sflash_delay */
+	volatile u32 i = 32 * 2;
+
+	while (i--)
+		;
+
+	bflb_sf_ctrl_set_owner(SF_CTRL_OWNER_SAHB);
+	/* exit form continuous read for accepting command */
+	bflb_sflash_reset_continue_read(p_flash_cfg);
+	/*
+	 * for disable command that is setting register instaed of send command,
+	 * we need write enable
+	 */
+	bflb_sflash_disable_burst_wrap(p_flash_cfg);
+	/* enable 32Bits addr mode again in case reset command make it reset */
+	bflb_sflash_set_32bits_addr_mode(p_flash_cfg, 1);
+	if ((p_flash_cfg->io_mode & 0x0f) == SF_CTRL_QO_MODE ||
+	    (p_flash_cfg->io_mode & 0x0f) == SF_CTRL_QIO_MODE) {
+		/* enable QE again in case reset command make it reset */
+		bflb_sflash_qspi_enable(p_flash_cfg);
+	}
+	/* deburst again to make sure */
+	bflb_sflash_disable_burst_wrap(p_flash_cfg);
+
+	/* clear offset setting */
+	*offset = bflb_sf_ctrl_get_flash_image_offset(group, bank);
+	bflb_sf_ctrl_set_flash_image_offset(0, group, bank);
+	return 0;
+}
+
+static int bflb_xip_sflash_state_restore(spi_flash_cfg_type *p_flash_cfg,
+					 u32 offset, u8 group, u8 bank)
+{
+	u32 tmp[1];
+	u8 io_mode = p_flash_cfg->io_mode & 0xf;
+
+	bflb_sf_ctrl_set_flash_image_offset(offset, group, bank);
+
+	if (((p_flash_cfg->io_mode >> 4) & 0x01) == 0) {
+		if ((p_flash_cfg->io_mode & 0x0f) == SF_CTRL_QO_MODE ||
+		    (p_flash_cfg->io_mode & 0x0f) == SF_CTRL_QIO_MODE) {
+			bflb_sflash_set_burst_wrap(p_flash_cfg);
+		}
+	}
+	bflb_sflash_set_32bits_addr_mode(p_flash_cfg, 1);
+	bflb_sflash_read(p_flash_cfg, io_mode, 1, 0x0, (u8 *)tmp, sizeof(tmp));
+	bflb_sflash_set_xip_cfg(p_flash_cfg, io_mode, 1, 0, 32, bank);
+	return 0;
+}
+
+static void bflb_xip_sflash_opt_enter(u8 *aes_enable)
+{
+	*aes_enable = bflb_sf_ctrl_is_aes_enable();
+
+	if (*aes_enable)
+		bflb_sf_ctrl_aes_disable();
+}
+
+static void bflb_xip_sflash_opt_exit(u8 aes_enable)
+{
+	if (aes_enable)
+		bflb_sf_ctrl_aes_enable();
+}
+
+static int bflb_xip_sflash_erase_need_lock(spi_flash_cfg_type *p_flash_cfg,
+					   u32 start_addr, int len, u8 group, u8 bank)
+{
+	int stat = 0;
+	u32 offset = 0;
+	u8 aes_enable = 0;
+	u8 io_mode = p_flash_cfg->io_mode & 0xf;
+
+	bflb_xip_sflash_opt_enter(&aes_enable);
+	stat = bflb_xip_sflash_state_save(p_flash_cfg, &offset, group, bank);
+
+	if (stat != 0) {
+		bflb_sflash_set_xip_cfg(p_flash_cfg, io_mode, 1, 0, 32, bank);
+	} else {
+		stat = bflb_sflash_erase(p_flash_cfg, start_addr, start_addr + len - 1);
+		bflb_xip_sflash_state_restore(p_flash_cfg, offset, group, bank);
+	}
+
+	bflb_xip_sflash_opt_exit(aes_enable);
+	return stat;
+}
+
+static int bflb_xip_sflash_write_need_lock(spi_flash_cfg_type *p_flash_cfg,
+					   u32 addr, u8 *data, u32 len, u8 group, u8 bank)
+{
+	int stat = 0;
+	u32 offset = 0;
+	u8 aes_enable = 0;
+	u8 io_mode = p_flash_cfg->io_mode & 0xf;
+
+	bflb_xip_sflash_opt_enter(&aes_enable);
+	stat = bflb_xip_sflash_state_save(p_flash_cfg, &offset, group, bank);
+
+	if (stat != 0) {
+		bflb_sflash_set_xip_cfg(p_flash_cfg, io_mode, 1, 0, 32, bank);
+	} else {
+		stat = bflb_sflash_program(p_flash_cfg, io_mode, addr, data, len);
+		bflb_xip_sflash_state_restore(p_flash_cfg, offset, group, bank);
+	}
+
+	bflb_xip_sflash_opt_exit(aes_enable);
+	return stat;
+}
+
+static int bflb_xip_sflash_read_need_lock(spi_flash_cfg_type *p_flash_cfg,
+					  u32 addr, u8 *data, u32 len, u8 group, u8 bank)
+{
+	int stat = 0;
+	u32 offset = 0;
+	u8 aes_enable = 0;
+	u8 io_mode = p_flash_cfg->io_mode & 0xf;
+
+	bflb_xip_sflash_opt_enter(&aes_enable);
+	stat = bflb_xip_sflash_state_save(p_flash_cfg, &offset, group, bank);
+
+	if (stat != 0) {
+		bflb_sflash_set_xip_cfg(p_flash_cfg, io_mode, 1, 0, 32, bank);
+	} else {
+		stat = bflb_sflash_read(p_flash_cfg, io_mode, 0, addr, data, len);
+		bflb_xip_sflash_state_restore(p_flash_cfg, offset, group, bank);
+	}
+
+	bflb_xip_sflash_opt_exit(aes_enable);
+	return stat;
+}
+
+static int bflb_mtd_sf_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
+{
+	return 0;
+}
+
+static int bflb_mtd_sf_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
+{
+	return 0;
+}
+
+static void bflb_mtd_sf_sync(struct mtd_info *mtd)
+{
+}
+
+static int bflb_mtd_sf_write(struct mtd_info *mtd, loff_t to, size_t len,
+			     size_t *retlen, const u_char *buf)
+{
+	int err;
+
+	err = bflb_xip_sflash_write_need_lock(&g_flash_cfg, (u32)to,
+					      (u8 *)buf, (u32)len, 0, 0);
+	if (err) {
+		if (retlen)
+			*retlen = 0;
+
+		return -EIO;
+	}
+
+	if (retlen)
+		*retlen = len;
+	return 0;
+}
+
+/*
+ * Note: it's okay to read data from flash in way of XIP if
+ * write transactions are not involved, otherwise cache data
+ * consistency has to been considered.
+ */
+static int bflb_mtd_sf_read(struct mtd_info *mtd, loff_t from, size_t len,
+			    size_t *retlen, u_char *buf)
+{
+	int err;
+
+	err = bflb_xip_sflash_read_need_lock(&g_flash_cfg, (u32)from, buf,
+					     (u32)len, 0, 0);
+	if (err) {
+		printf("mtd sf read failed, %d\n", err);
+		if (retlen)
+			*retlen = 0;
+
+		return -EIO;
+	}
+
+	if (retlen)
+		*retlen = len;
+	return 0;
+}
+
+static int bflb_mtd_sf_erase(struct mtd_info *mtd, struct erase_info *instr)
+{
+	int err;
+	u32 flash_addr = (u32)instr->addr;
+	u32 len = (u32)instr->len;
+
+	err = bflb_xip_sflash_erase_need_lock(&g_flash_cfg, flash_addr, len, 0, 0);
+	if (err) {
+		instr->fail_addr = MTD_FAIL_ADDR_UNKNOWN;
+		instr->state = MTD_ERASE_FAILED;
+		return -EIO;
+	}
+
+	instr->state = MTD_ERASE_DONE;
+	return 0;
+}
+
+/* TODO put this in driver's probe function */
+static struct mtd_info *bflb_mtd_setup(void)
+{
+	struct mtd_info *mtd;
+
+	mtd = calloc(1, sizeof(struct mtd_info));
+	if (!mtd) {
+		printf("no mem for mtd_info\n");
+		return ERR_PTR(-ENOMEM);
+	}
+
+	mtd->dev = NULL;
+	mtd->name = "nor0";
+	mtd->type = MTD_NORFLASH;
+	mtd->flags = MTD_CAP_NORFLASH;
+	mtd->size = BFLB_FLASH_SIZE;
+	mtd->writesize = 1;
+	mtd->writebufsize = mtd->writesize;
+	mtd->_erase = bflb_mtd_sf_erase;
+	mtd->_read = bflb_mtd_sf_read;
+	mtd->_write = bflb_mtd_sf_write;
+	mtd->_sync = bflb_mtd_sf_sync;
+	mtd->_lock = bflb_mtd_sf_lock;
+	mtd->_unlock = bflb_mtd_sf_unlock;
+	mtd->numeraseregions = 0;
+	mtd->erasesize = g_flash_cfg.sector_size * 1024;
+	if (add_mtd_device(mtd)) {
+		printf("failed to add mtd device %s\n", mtd->name);
+		free(mtd);
+		return NULL;
+	}
+	return mtd;
+}
+
+/*
+ * @brief: this function is called in board_init_r.
+ */
+unsigned long flash_init(void)
+{
+	int i, j;
+	struct mtd_info *mtd;
+	unsigned long total_size = 0;
+	unsigned long sector_size = g_flash_cfg.sector_size * 1024;
+
+	mtd = bflb_mtd_setup();
+	if (IS_ERR_OR_NULL(mtd)) {
+		printf("flash init failed due to mtd info(NULL)\n");
+		return -1;
+	}
+
+	bflb_sf_ctrl_set_flash_image_offset(0, 1, SF_CTRL_FLASH_BANK0);
+	for (i = 0; i < CONFIG_SYS_MAX_FLASH_BANKS; i++) {
+		flash_info[i].mtd = mtd;
+		flash_info[i].flash_id = BFLB_FLASH_ID;
+		flash_info[i].size = BFLB_FLASH_SIZE;
+		flash_info[i].sector_count = BFLB_FLASH_SIZE / sector_size;
+		flash_info[i].start[0] = BFLB_SYS_FLASH_BASE;
+
+		for (j = 1; j < flash_info[i].sector_count; j++)
+			flash_info[i].start[j] = flash_info[i].start[j - 1] + sector_size;
+		total_size += flash_info[i].size;
+	}
+
+	return total_size;
+}
+
+void flash_print_info(flash_info_t *info)
+{
+	int i;
+
+	if (info->flash_id != BFLB_FLASH_ID) {
+		printf("missing or unknown FLASH type\n");
+		return;
+	}
+
+	printf("Bouffalo Lab BL808 Embedded Flash\n\n");
+	printf("  Size: %ld MB in %d Sectors\n",
+	       info->size >> 20, info->sector_count);
+
+	printf("  Sector Start Addresses:");
+	for (i = 0; i < info->sector_count; ++i) {
+		if ((i % 5) == 0)
+			printf("\n   ");
+		printf(" %08lX%s",
+		       info->start[i],
+				info->protect[i] ? " (RO)" : "     ");
+	}
+	printf("\n");
+}
+
+int flash_erase(flash_info_t *info, int first_sect, int last_sect)
+{
+	struct erase_info instr;
+	struct mtd_info *mtd = info->mtd;
+
+	memset(&instr, 0, sizeof(instr));
+	instr.mtd = mtd;
+	instr.addr = mtd->erasesize * first_sect;
+	instr.len = mtd->erasesize * (last_sect - first_sect + 1);
+	if (mtd_erase(mtd, &instr))
+		return ERR_PROTECTED;
+
+	return 0;
+}
+
+int write_buff(flash_info_t *info, uchar *src, ulong addr, ulong cnt)
+{
+	int err;
+	size_t retlen;
+	struct mtd_info *mtd = info->mtd;
+	loff_t to = addr - BFLB_SYS_FLASH_BASE;
+
+	err = mtd_write(mtd, to, cnt, &retlen, src);
+	if (err)
+		return ERR_PROTECTED;
+
+	return 0;
+}
+
+int flash_real_protect(flash_info_t *info, long sector, int prot)
+{
+	printf("%s is not supported yet\n", __func__);
+	return ERR_OK;
+}
+
+void flash_read_user_serial(flash_info_t *info, void *buffer,
+			    int offset, int len)
+{
+	printf("%s is not supported yet\n", __func__);
+}
+
+void flash_read_factory_serial(flash_info_t *info, void *buffer,
+			       int offset, int len)
+{
+	printf("%s is not supported yet\n", __func__);
+}
diff --git a/board/bflb/bl808/bflb_flash.h b/board/bflb/bl808/bflb_flash.h
new file mode 100644
index 0000000000..eebc7935cc
--- /dev/null
+++ b/board/bflb/bl808/bflb_flash.h
@@ -0,0 +1,1160 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright (c) Bouffalo Lab
+ */
+
+#ifndef __BFLB_FLASH_H
+#define __BFLB_FLASH_H
+
+/*
+ * @brief Serial flash configuration structure type definition
+ */
+typedef struct {
+	/* Serail flash interface mode,bit0-3:IF mode,bit4:unwrap,bit5:32-bits addr mode support */
+	u8  io_mode;
+	/* Support continuous read mode,bit0:continuous read mode support,bit1:read mode cfg */
+	u8  c_read_support;
+	/* SPI clock delay,bit0-3:delay,bit4-6:pad delay */
+	u8  clk_delay;
+	/* SPI clock phase invert,bit0:clck invert,bit1:rx invert,bit2-4:pad delay,bit5-7:pad delay */
+	u8  clk_invert;
+	/* Flash enable reset command */
+	u8  reset_en_cmd;
+	/* Flash reset command */
+	u8  reset_cmd;
+	/* Flash reset continuous read command */
+	u8  reset_c_read_cmd;
+	/* Flash reset continuous read command size */
+	u8  reset_c_read_cmd_size;
+	/* JEDEC ID command */
+	u8  jedec_id_cmd;
+	/* JEDEC ID command dummy clock */
+	u8  jedec_id_cmd_dmy_clk;
+	/* Enter 32-bits addr command */
+	u8  enter_32bits_addr_cmd;
+	/* Exit 32-bits addr command */
+	u8  exit_32bits_addr_cmd;
+	/* *1024bytes */
+	u8  sector_size;
+	/* Manufacturer ID */
+	u8  mid;
+	/* Page size */
+	u16 page_size;
+	/* Chip erase cmd */
+	u8  chip_erase_cmd;
+	/* Sector erase command */
+	u8  sector_erase_cmd;
+	/* Block 32K erase command,some Micron not support */
+	u8  blk32_erase_cmd;
+	/* Block 64K erase command */
+	u8  blk64_erase_cmd;
+	/* Need before every erase or program */
+	u8  write_enable_cmd;
+	/* Page program cmd */
+	u8  page_program_cmd;
+	/* QIO page program cmd */
+	u8  qpage_program_cmd;
+	/* QIO page program address mode */
+	u8  qpp_addr_mode;
+	/* Fast read command */
+	u8  fast_read_cmd;
+	/* Fast read command dummy clock */
+	u8  fr_dmy_clk;
+	/* QPI fast read command */
+	u8  qpi_fast_read_cmd;
+	/* QPI fast read command dummy clock */
+	u8  qpi_fr_dmy_clk;
+	/* Fast read dual output command */
+	u8  fast_read_do_cmd;
+	/* Fast read dual output command dummy clock */
+	u8  fr_do_dmy_clk;
+	/* Fast read dual io comamnd */
+	u8  fast_read_dio_cmd;
+	/* Fast read dual io command dummy clock */
+	u8  fr_dio_dmy_clk;
+	/* Fast read quad output comamnd */
+	u8  fast_read_qo_cmd;
+	/* Fast read quad output comamnd dummy clock */
+	u8  fr_qo_dmy_clk;
+	/* Fast read quad io comamnd */
+	u8  fast_read_qio_cmd;
+	/* Fast read quad io comamnd dummy clock */
+	u8  fr_qio_dmy_clk;
+	/* QPI fast read quad io comamnd */
+	u8  qpi_fast_read_qio_cmd;
+	/* QPI fast read QIO dummy clock */
+	u8  qpi_fr_qio_dmy_clk;
+	/* QPI program command */
+	u8  qpi_page_program_cmd;
+	/* Enable write reg */
+	u8  write_vreg_enable_cmd;
+	/* Write enable register index */
+	u8  wr_enable_index;
+	/* Quad mode enable register index */
+	u8  qe_index;
+	/* Busy status register index */
+	u8  busy_index;
+	/* Write enable bit pos */
+	u8  wr_enable_bit;
+	/* Quad enable bit pos */
+	u8  qe_bit;
+	/* Busy status bit pos */
+	u8  busy_bit;
+	/* Register length of write enable */
+	u8  wr_enable_write_reg_len;
+	/* Register length of write enable status */
+	u8  wr_enable_read_reg_len;
+	/* Register length of contain quad enable */
+	u8  qe_write_reg_len;
+	/* Register length of contain quad enable status */
+	u8  qe_read_reg_len;
+	/* Release power down command */
+	u8  release_powerdown;
+	/* Register length of contain busy status */
+	u8  busy_read_reg_len;
+	/* Read register command buffer */
+	u8  read_reg_cmd[4];
+	/* Write register command buffer */
+	u8  write_reg_cmd[4];
+	/* Enter qpi command */
+	u8  enter_qpi;
+	/* Exit qpi command */
+	u8  exit_qpi;
+	/* Config data for continuous read mode */
+	u8  c_read_mode;
+	/* Config data for exit continuous read mode */
+	u8  c_rexit;
+	/* Enable burst wrap command */
+	u8  burst_wrap_cmd;
+	/* Enable burst wrap command dummy clock */
+	u8  burst_wrap_cmd_dmy_clk;
+	/* Data and address mode for this command */
+	u8  burst_wrap_data_mode;
+	/* Data to enable burst wrap */
+	u8  burst_wrap_data;
+	/* Disable burst wrap command */
+	u8  de_burst_wrap_cmd;
+	/* Disable burst wrap command dummy clock */
+	u8  de_burst_wrap_cmd_dmy_clk;
+	/* Data and address mode for this command */
+	u8  de_burst_wrap_data_mode;
+	/* Data to disable burst wrap */
+	u8  de_burst_wrap_data;
+	/* 4K erase time */
+	u16 time_e_sector;
+	/* 32K erase time */
+	u16 time_e_32k;
+	/* 64K erase time */
+	u16 time_e_64k;
+	/* Page program time */
+	u16 time_page_pgm;
+	/* Chip erase time in ms */
+	u16 time_ce;
+	/* Release power down command delay time for wake up */
+	u8  pd_delay;
+	/* QE set data */
+	u8  qe_data;
+} __packed spi_flash_cfg_type;
+
+#define BFLB_SPIFLASH_BLK32K_SIZE (32 * 1024)
+#define BFLB_SPIFLASH_BLK64K_SIZE (64 * 1024)
+#define BFLB_SPIFLASH_CMD_INVALID 0xff
+
+#define BFLB_SF_CTRL_BASE      ((uint32_t)0x2000b000)
+#define BFLB_SF_CTRL_BUF_BASE  ((uint32_t)0x2000b600)
+
+/**
+ *  @brief Serial flash select bank control type definition
+ */
+#define SF_CTRL_FLASH_BANK0                  0    /* SF Ctrl select flash bank0 */
+#define SF_CTRL_FLASH_BANK1                  1    /* SF Ctrl select flash bank1 */
+
+/**
+ *  @brief Serail flash controller memory remap type define
+ */
+#define SF_CTRL_ORIGINAL_MEMORY_MAP          0    /* Remap none, use two addr map when use dual flash */
+#define SF_CTRL_REMAP_16MB                   1    /* Remap HADDR>16MB region to psram port HADDR[24] -> HADDR[28] */
+#define SF_CTRL_REMAP_8MB                    2    /* Remap HADDR>8MB region to psram port HADDR[23] -> HADDR[28] */
+#define SF_CTRL_REMAP_4MB                    3    /* Remap HADDR>4MB region to psram port HADDR[22] -> HADDR[28] */
+
+/**
+ *  @brief Serial flash controller select clock type definition
+ */
+#define SF_CTRL_OWNER_SAHB                   0    /* System AHB bus control serial flash controller */
+#define SF_CTRL_OWNER_IAHB                   1    /* I-Code AHB bus control serial flash controller */
+
+/**
+ *  @brief Serial flash controller select clock type definition
+ */
+#define SF_CTRL_SAHB_CLOCK                   0    /* Serial flash controller select default sahb clock */
+#define SF_CTRL_FLASH_CLOCK                  1    /* Serial flash controller select flash clock */
+
+/**
+ *  @brief Read and write type definition
+ */
+#define SF_CTRL_READ                         0    /* Serail flash read command flag */
+#define SF_CTRL_WRITE                        1    /* Serail flash write command flag */
+
+/**
+ *  @brief Serail flash interface IO type definition
+ */
+#define SF_CTRL_NIO_MODE                     0    /* Normal IO mode define */
+#define SF_CTRL_DO_MODE                      1    /* Dual Output mode define */
+#define SF_CTRL_QO_MODE                      2    /* Quad Output mode define */
+#define SF_CTRL_DIO_MODE                     3    /* Dual IO mode define */
+#define SF_CTRL_QIO_MODE                     4    /* Quad IO mode define */
+
+/**
+ *  @brief Serail flash controller command mode type definition
+ */
+#define SF_CTRL_CMD_1_LINE                   0   /* Command in one line mode */
+#define SF_CTRL_CMD_4_LINES                  1   /* Command in four lines mode */
+
+/**
+ *  @brief Serail flash controller address mode type definition
+ */
+#define SF_CTRL_ADDR_1_LINE                  0    /* Address in one line mode */
+#define SF_CTRL_ADDR_2_LINES                 1    /* Address in two lines mode */
+#define SF_CTRL_ADDR_4_LINES                 2    /* Address in four lines mode */
+
+/**
+ *  @brief Serail flash controller data mode type definition
+ */
+#define SF_CTRL_DATA_1_LINE                  0    /* Data in one line mode */
+#define SF_CTRL_DATA_2_LINES                 1    /* Data in two lines mode */
+#define SF_CTRL_DATA_4_LINES                 2    /* Data in four lines mode */
+
+/**
+ *  @brief Serail flash command configuration structure type definition
+ */
+struct sf_ctrl_cmd_cfg_type {
+	/* Read write flag */
+	u8 rw_flag;
+	/* Command mode */
+	u8 cmd_mode;
+	/* Address mode */
+	u8 addr_mode;
+	/* Address size */
+	u8 addr_size;
+	/* Dummy clocks */
+	u8 dummy_clks;
+	/* Dummy mode */
+	u8 dummy_mode;
+	/* Data mode */
+	u8 data_mode;
+	/* Reserved */
+	u8 rsv[1];
+	/* Transfer number of bytes */
+	u32 nb_data;
+	/* Command buffer */
+	u32 cmd_buf[2];
+};
+
+#define SF_CTRL_BUSY_STATE_TIMEOUT  (5 * 320 * 1000)
+#define NOR_FLASH_CTRL_BUF_SIZE     256
+
+/* sf ctrl register offsets */
+#define SF_CTRL_0_OFFSET                         (0x0)/* sf_ctrl_0 */
+#define SF_CTRL_1_OFFSET                         (0x4)/* sf_ctrl_1 */
+#define SF_CTRL_SF_IF_SAHB_0_OFFSET              (0x8)/* sf_if_sahb_0 */
+#define SF_CTRL_SF_IF_SAHB_1_OFFSET              (0xC)/* sf_if_sahb_1 */
+#define SF_CTRL_SF_IF_SAHB_2_OFFSET              (0x10)/* sf_if_sahb_2 */
+#define SF_CTRL_SF_IF_IAHB_0_OFFSET              (0x14)/* sf_if_iahb_0 */
+#define SF_CTRL_SF_IF_IAHB_1_OFFSET              (0x18)/* sf_if_iahb_1 */
+#define SF_CTRL_SF_IF_IAHB_2_OFFSET              (0x1C)/* sf_if_iahb_2 */
+#define SF_CTRL_SF_IF_STATUS_0_OFFSET            (0x20)/* sf_if_status_0 */
+#define SF_CTRL_SF_IF_STATUS_1_OFFSET            (0x24)/* sf_if_status_1 */
+#define SF_CTRL_SF_AES_OFFSET                    (0x28)/* sf_aes */
+#define SF_CTRL_SF_AHB2SIF_STATUS_OFFSET         (0x2C)/* sf_ahb2sif_status */
+#define SF_CTRL_SF_IF_IO_DLY_0_OFFSET            (0x30)/* sf_if_io_dly_0 */
+#define SF_CTRL_SF_IF_IO_DLY_1_OFFSET            (0x34)/* sf_if_io_dly_1 */
+#define SF_CTRL_SF_IF_IO_DLY_2_OFFSET            (0x38)/* sf_if_io_dly_2 */
+#define SF_CTRL_SF_IF_IO_DLY_3_OFFSET            (0x3C)/* sf_if_io_dly_3 */
+#define SF_CTRL_SF_IF_IO_DLY_4_OFFSET            (0x40)/* sf_if_io_dly_4 */
+#define SF_CTRL_SF_RESERVED_OFFSET               (0x44)/* sf_reserved */
+#define SF_CTRL_SF2_IF_IO_DLY_0_OFFSET           (0x48)/* sf2_if_io_dly_0 */
+#define SF_CTRL_SF2_IF_IO_DLY_1_OFFSET           (0x4C)/* sf2_if_io_dly_1 */
+#define SF_CTRL_SF2_IF_IO_DLY_2_OFFSET           (0x50)/* sf2_if_io_dly_2 */
+#define SF_CTRL_SF2_IF_IO_DLY_3_OFFSET           (0x54)/* sf2_if_io_dly_3 */
+#define SF_CTRL_SF2_IF_IO_DLY_4_OFFSET           (0x58)/* sf2_if_io_dly_4 */
+#define SF_CTRL_SF3_IF_IO_DLY_0_OFFSET           (0x5C)/* sf3_if_io_dly_0 */
+#define SF_CTRL_SF3_IF_IO_DLY_1_OFFSET           (0x60)/* sf3_if_io_dly_1 */
+#define SF_CTRL_SF3_IF_IO_DLY_2_OFFSET           (0x64)/* sf3_if_io_dly_2 */
+#define SF_CTRL_SF3_IF_IO_DLY_3_OFFSET           (0x68)/* sf3_if_io_dly_3 */
+#define SF_CTRL_SF3_IF_IO_DLY_4_OFFSET           (0x6C)/* sf3_if_io_dly_4 */
+#define SF_CTRL_2_OFFSET                         (0x70)/* sf_ctrl_2 */
+#define SF_CTRL_3_OFFSET                         (0x74)/* sf_ctrl_3 */
+#define SF_CTRL_SF_IF_IAHB_3_OFFSET              (0x78)/* sf_if_iahb_3 */
+#define SF_CTRL_SF_IF_IAHB_4_OFFSET              (0x7C)/* sf_if_iahb_4 */
+#define SF_CTRL_SF_IF_IAHB_5_OFFSET              (0x80)/* sf_if_iahb_5 */
+#define SF_CTRL_SF_IF_IAHB_6_OFFSET              (0x84)/* sf_if_iahb_6 */
+#define SF_CTRL_SF_IF_IAHB_7_OFFSET              (0x88)/* sf_if_iahb_7 */
+#define SF_CTRL_SF_IF_IAHB_8_OFFSET              (0x8C)/* sf_if_iahb_8 */
+#define SF_CTRL_SF_IF_IAHB_9_OFFSET              (0x90)/* sf_if_iahb_9 */
+#define SF_CTRL_SF_IF_IAHB_10_OFFSET             (0x94)/* sf_if_iahb_10 */
+#define SF_CTRL_SF_IF_IAHB_11_OFFSET             (0x98)/* sf_if_iahb_11 */
+#define SF_CTRL_SF_IF_IAHB_12_OFFSET             (0x9C)/* sf_if_iahb_12 */
+#define SF_CTRL_SF_ID0_OFFSET_OFFSET             (0xA0)/* sf_id0_offset */
+#define SF_CTRL_SF_ID1_OFFSET_OFFSET             (0xA4)/* sf_id1_offset */
+#define SF_CTRL_SF_BK2_ID0_OFFSET_OFFSET         (0xA8)/* sf_bk2_id0_offset */
+#define SF_CTRL_SF_BK2_ID1_OFFSET_OFFSET         (0xAC)/* sf_bk2_id1_offset */
+#define SF_CTRL_SF_DBG_OFFSET                    (0xB0)/* sf_dbg */
+#define SF_CTRL_SF_IF2_CTRL_0_OFFSET             (0xC0)/* sf_if2_ctrl_0 */
+#define SF_CTRL_SF_IF2_CTRL_1_OFFSET             (0xC4)/* sf_if2_ctrl_1 */
+#define SF_CTRL_SF_IF2_SAHB_0_OFFSET             (0xC8)/* sf_if2_sahb_0 */
+#define SF_CTRL_SF_IF2_SAHB_1_OFFSET             (0xCC)/* sf_if2_sahb_1 */
+#define SF_CTRL_SF_IF2_SAHB_2_OFFSET             (0xD0)/* sf_if2_sahb_2 */
+#define SF_CTRL_PROT_EN_RD_OFFSET                (0x100)/* sf_ctrl_prot_en_rd */
+#define SF_CTRL_PROT_EN_OFFSET                   (0x104)/* sf_ctrl_prot_en */
+#define SF_CTRL_SF_AES_KEY_R0_0_OFFSET           (0x200)/* sf_aes_key_r0_0 */
+#define SF_CTRL_SF_AES_KEY_R0_1_OFFSET           (0x204)/* sf_aes_key_r0_1 */
+#define SF_CTRL_SF_AES_KEY_R0_2_OFFSET           (0x208)/* sf_aes_key_r0_2 */
+#define SF_CTRL_SF_AES_KEY_R0_3_OFFSET           (0x20C)/* sf_aes_key_r0_3 */
+#define SF_CTRL_SF_AES_KEY_R0_4_OFFSET           (0x210)/* sf_aes_key_r0_4 */
+#define SF_CTRL_SF_AES_KEY_R0_5_OFFSET           (0x214)/* sf_aes_key_r0_5 */
+#define SF_CTRL_SF_AES_KEY_R0_6_OFFSET           (0x218)/* sf_aes_key_r0_6 */
+#define SF_CTRL_SF_AES_KEY_R0_7_OFFSET           (0x21C)/* sf_aes_key_r0_7 */
+#define SF_CTRL_SF_AES_IV_R0_W0_OFFSET           (0x220)/* sf_aes_iv_r0_w0 */
+#define SF_CTRL_SF_AES_IV_R0_W1_OFFSET           (0x224)/* sf_aes_iv_r0_w1 */
+#define SF_CTRL_SF_AES_IV_R0_W2_OFFSET           (0x228)/* sf_aes_iv_r0_w2 */
+#define SF_CTRL_SF_AES_IV_R0_W3_OFFSET           (0x22C)/* sf_aes_iv_r0_w3 */
+#define SF_CTRL_SF_AES_R0_START_OFFSET           (0x230)/* sf_aes_r0_start */
+#define SF_CTRL_SF_AES_R0_END_OFFSET             (0x234)/* sf_aes_r0_end */
+#define SF_CTRL_SF_AES_KEY_R1_0_OFFSET           (0x280)/* sf_aes_key_r1_0 */
+#define SF_CTRL_SF_AES_KEY_R1_1_OFFSET           (0x284)/* sf_aes_key_r1_1 */
+#define SF_CTRL_SF_AES_KEY_R1_2_OFFSET           (0x288)/* sf_aes_key_r1_2 */
+#define SF_CTRL_SF_AES_KEY_R1_3_OFFSET           (0x28C)/* sf_aes_key_r1_3 */
+#define SF_CTRL_SF_AES_KEY_R1_4_OFFSET           (0x290)/* sf_aes_key_r1_4 */
+#define SF_CTRL_SF_AES_KEY_R1_5_OFFSET           (0x294)/* sf_aes_key_r1_5 */
+#define SF_CTRL_SF_AES_KEY_R1_6_OFFSET           (0x298)/* sf_aes_key_r1_6 */
+#define SF_CTRL_SF_AES_KEY_R1_7_OFFSET           (0x29C)/* sf_aes_key_r1_7 */
+#define SF_CTRL_SF_AES_IV_R1_W0_OFFSET           (0x2A0)/* sf_aes_iv_r1_w0 */
+#define SF_CTRL_SF_AES_IV_R1_W1_OFFSET           (0x2A4)/* sf_aes_iv_r1_w1 */
+#define SF_CTRL_SF_AES_IV_R1_W2_OFFSET           (0x2A8)/* sf_aes_iv_r1_w2 */
+#define SF_CTRL_SF_AES_IV_R1_W3_OFFSET           (0x2AC)/* sf_aes_iv_r1_w3 */
+#define SF_CTRL_SF_AES_R1_START_OFFSET           (0x2B0)/* sf_aes_r1_start */
+#define SF_CTRL_SF_AES_R1_END_OFFSET             (0x2B4)/* sf_aes_r1_end */
+#define SF_CTRL_SF_AES_KEY_R2_0_OFFSET           (0x300)/* sf_aes_key_r2_0 */
+#define SF_CTRL_SF_AES_KEY_R2_1_OFFSET           (0x304)/* sf_aes_key_r2_1 */
+#define SF_CTRL_SF_AES_KEY_R2_2_OFFSET           (0x308)/* sf_aes_key_r2_2 */
+#define SF_CTRL_SF_AES_KEY_R2_3_OFFSET           (0x30C)/* sf_aes_key_r2_3 */
+#define SF_CTRL_SF_AES_KEY_R2_4_OFFSET           (0x310)/* sf_aes_key_r2_4 */
+#define SF_CTRL_SF_AES_KEY_R2_5_OFFSET           (0x314)/* sf_aes_key_r2_5 */
+#define SF_CTRL_SF_AES_KEY_R2_6_OFFSET           (0x318)/* sf_aes_key_r2_6 */
+#define SF_CTRL_SF_AES_KEY_R2_7_OFFSET           (0x31C)/* sf_aes_key_r2_7 */
+#define SF_CTRL_SF_AES_IV_R2_W0_OFFSET           (0x320)/* sf_aes_iv_r2_w0 */
+#define SF_CTRL_SF_AES_IV_R2_W1_OFFSET           (0x324)/* sf_aes_iv_r2_w1 */
+#define SF_CTRL_SF_AES_IV_R2_W2_OFFSET           (0x328)/* sf_aes_iv_r2_w2 */
+#define SF_CTRL_SF_AES_IV_R2_W3_OFFSET           (0x32C)/* sf_aes_iv_r2_w3 */
+#define SF_CTRL_SF_AES_R2_START_OFFSET           (0x330)/* sf_aes_r2_start */
+#define SF_CTRL_SF_AES_R2_END_OFFSET             (0x334)/* sf_aes_r2_end */
+
+/* Register Bitfield definitions */
+/* 0x0 : sf_ctrl_0 */
+#define SF_CTRL_SF_CLK_SF_RX_INV_SEL             BIT(2)
+#define SF_CTRL_SF_CLK_OUT_GATE_EN               BIT(3)
+#define SF_CTRL_SF_CLK_OUT_INV_SEL               BIT(4)
+#define SF_CTRL_SF_IF_READ_DLY_N_SHIFT           (8U)
+#define SF_CTRL_SF_IF_READ_DLY_N_MASK            (0x7 << SF_CTRL_SF_IF_READ_DLY_N_SHIFT)
+#define SF_CTRL_SF_IF_READ_DLY_EN                BIT(11)
+#define SF_CTRL_SF_IF_INT                        BIT(16)
+#define SF_CTRL_SF_IF_INT_CLR                    BIT(17)
+#define SF_CTRL_SF_IF_INT_SET                    BIT(18)
+#define SF_CTRL_SF_IF_32B_ADR_EN                 BIT(19)
+#define SF_CTRL_SF_AES_DOUT_ENDIAN               BIT(20)
+#define SF_CTRL_SF_AES_DIN_ENDIAN                BIT(21)
+#define SF_CTRL_SF_AES_KEY_ENDIAN                BIT(22)
+#define SF_CTRL_SF_AES_IV_ENDIAN                 BIT(23)
+#define SF_CTRL_SF_ID_SHIFT                      (24U)
+#define SF_CTRL_SF_ID_MASK                       (0xff << SF_CTRL_SF_ID_SHIFT)
+
+/* 0x4 : sf_ctrl_1 */
+#define SF_CTRL_SF_IF_SR_PAT_MASK_SHIFT          (0U)
+#define SF_CTRL_SF_IF_SR_PAT_MASK_MASK           (0xff << SF_CTRL_SF_IF_SR_PAT_MASK_SHIFT)
+#define SF_CTRL_SF_IF_SR_PAT_SHIFT               (8U)
+#define SF_CTRL_SF_IF_SR_PAT_MASK                (0xff << SF_CTRL_SF_IF_SR_PAT_SHIFT)
+#define SF_CTRL_SF_IF_SR_INT                     BIT(16)
+#define SF_CTRL_SF_IF_SR_INT_EN                  BIT(17)
+#define SF_CTRL_SF_IF_SR_INT_SET                 BIT(18)
+#define SF_CTRL_SF_IF_0_ACK_LAT_SHIFT            (20U)
+#define SF_CTRL_SF_IF_0_ACK_LAT_MASK             (0x7 << SF_CTRL_SF_IF_0_ACK_LAT_SHIFT)
+#define SF_CTRL_SF_AHB2SIF_DISWRAP               BIT(23)
+#define SF_CTRL_SF_IF_REG_HOLD                   BIT(24)
+#define SF_CTRL_SF_IF_REG_WP                     BIT(25)
+#define SF_CTRL_SF_AHB2SIF_STOPPED               BIT(26)
+#define SF_CTRL_SF_AHB2SIF_STOP                  BIT(27)
+#define SF_CTRL_SF_IF_FN_SEL                     BIT(28)
+#define SF_CTRL_SF_IF_EN                         BIT(29)
+#define SF_CTRL_SF_AHB2SIF_EN                    BIT(30)
+#define SF_CTRL_SF_AHB2SRAM_EN                   BIT(31)
+
+/* 0x8 : sf_if_sahb_0 */
+#define SF_CTRL_SF_IF_BUSY                       BIT(0)
+#define SF_CTRL_SF_IF_0_TRIG                     BIT(1)
+#define SF_CTRL_SF_IF_0_DAT_BYTE_SHIFT           (2U)
+#define SF_CTRL_SF_IF_0_DAT_BYTE_MASK            (0x3ff << SF_CTRL_SF_IF_0_DAT_BYTE_SHIFT)
+#define SF_CTRL_SF_IF_0_DMY_BYTE_SHIFT           (12U)
+#define SF_CTRL_SF_IF_0_DMY_BYTE_MASK            (0x1f << SF_CTRL_SF_IF_0_DMY_BYTE_SHIFT)
+#define SF_CTRL_SF_IF_0_ADR_BYTE_SHIFT           (17U)
+#define SF_CTRL_SF_IF_0_ADR_BYTE_MASK            (0x7 << SF_CTRL_SF_IF_0_ADR_BYTE_SHIFT)
+#define SF_CTRL_SF_IF_0_CMD_BYTE_SHIFT           (20U)
+#define SF_CTRL_SF_IF_0_CMD_BYTE_MASK            (0x7 << SF_CTRL_SF_IF_0_CMD_BYTE_SHIFT)
+#define SF_CTRL_SF_IF_0_DAT_RW                   BIT(23)
+#define SF_CTRL_SF_IF_0_DAT_EN                   BIT(24)
+#define SF_CTRL_SF_IF_0_DMY_EN                   BIT(25)
+#define SF_CTRL_SF_IF_0_ADR_EN                   BIT(26)
+#define SF_CTRL_SF_IF_0_CMD_EN                   BIT(27)
+#define SF_CTRL_SF_IF_0_SPI_MODE_SHIFT           (28U)
+#define SF_CTRL_SF_IF_0_SPI_MODE_MASK            (0x7 << SF_CTRL_SF_IF_0_SPI_MODE_SHIFT)
+#define SF_CTRL_SF_IF_0_QPI_MODE_EN              BIT(31)
+
+/* 0xC : sf_if_sahb_1 */
+#define SF_CTRL_SF_IF_0_CMD_BUF_0_SHIFT          (0U)
+#define SF_CTRL_SF_IF_0_CMD_BUF_0_MASK           (0xffffffffL << SF_CTRL_SF_IF_0_CMD_BUF_0_SHIFT)
+
+/* 0x10 : sf_if_sahb_2 */
+#define SF_CTRL_SF_IF_0_CMD_BUF_1_SHIFT          (0U)
+#define SF_CTRL_SF_IF_0_CMD_BUF_1_MASK           (0xffffffffL << SF_CTRL_SF_IF_0_CMD_BUF_1_SHIFT)
+
+/* 0x14 : sf_if_iahb_0 */
+#define SF_CTRL_SF_IF_1_DMY_BYTE_SHIFT           (12U)
+#define SF_CTRL_SF_IF_1_DMY_BYTE_MASK            (0x1f << SF_CTRL_SF_IF_1_DMY_BYTE_SHIFT)
+#define SF_CTRL_SF_IF_1_ADR_BYTE_SHIFT           (17U)
+#define SF_CTRL_SF_IF_1_ADR_BYTE_MASK            (0x7 << SF_CTRL_SF_IF_1_ADR_BYTE_SHIFT)
+#define SF_CTRL_SF_IF_1_CMD_BYTE_SHIFT           (20U)
+#define SF_CTRL_SF_IF_1_CMD_BYTE_MASK            (0x7 << SF_CTRL_SF_IF_1_CMD_BYTE_SHIFT)
+#define SF_CTRL_SF_IF_1_DAT_RW                   BIT(23)
+#define SF_CTRL_SF_IF_1_DAT_EN                   BIT(24)
+#define SF_CTRL_SF_IF_1_DMY_EN                   BIT(25)
+#define SF_CTRL_SF_IF_1_ADR_EN                   BIT(26)
+#define SF_CTRL_SF_IF_1_CMD_EN                   BIT(27)
+#define SF_CTRL_SF_IF_1_SPI_MODE_SHIFT           (28U)
+#define SF_CTRL_SF_IF_1_SPI_MODE_MASK            (0x7 << SF_CTRL_SF_IF_1_SPI_MODE_SHIFT)
+#define SF_CTRL_SF_IF_1_QPI_MODE_EN              BIT(31)
+
+/* 0x18 : sf_if_iahb_1 */
+#define SF_CTRL_SF_IF_1_CMD_BUF_0_SHIFT          (0U)
+#define SF_CTRL_SF_IF_1_CMD_BUF_0_MASK           (0xffffffffL << SF_CTRL_SF_IF_1_CMD_BUF_0_SHIFT)
+
+/* 0x1C : sf_if_iahb_2 */
+#define SF_CTRL_SF_IF_1_CMD_BUF_1_SHIFT          (0U)
+#define SF_CTRL_SF_IF_1_CMD_BUF_1_MASK           (0xffffffffL << SF_CTRL_SF_IF_1_CMD_BUF_1_SHIFT)
+
+/* 0x20 : sf_if_status_0 */
+#define SF_CTRL_SF_IF_STATUS_0_SHIFT             (0U)
+#define SF_CTRL_SF_IF_STATUS_0_MASK              (0xffffffffL << SF_CTRL_SF_IF_STATUS_0_SHIFT)
+
+/* 0x24 : sf_if_status_1 */
+#define SF_CTRL_SF_IF_STATUS_1_SHIFT             (0U)
+#define SF_CTRL_SF_IF_STATUS_1_MASK              (0xffffffffL << SF_CTRL_SF_IF_STATUS_1_SHIFT)
+
+/* 0x28 : sf_aes */
+#define SF_CTRL_SF_AES_EN                        BIT(0)
+#define SF_CTRL_SF_AES_MODE_SHIFT                (1U)
+#define SF_CTRL_SF_AES_MODE_MASK                 (0x3 << SF_CTRL_SF_AES_MODE_SHIFT)
+#define SF_CTRL_SF_AES_BLK_MODE                  BIT(3)
+#define SF_CTRL_SF_AES_XTS_KEY_OPT               BIT(4)
+#define SF_CTRL_SF_AES_STATUS_SHIFT              (5U)
+#define SF_CTRL_SF_AES_STATUS_MASK               (0x7ffffff << SF_CTRL_SF_AES_STATUS_SHIFT)
+
+/* 0x2C : sf_ahb2sif_status */
+#define SF_CTRL_SF_AHB2SIF_STATUS_SHIFT          (0U)
+#define SF_CTRL_SF_AHB2SIF_STATUS_MASK           (0xffffffffL << SF_CTRL_SF_AHB2SIF_STATUS_SHIFT)
+
+/* 0x30 : sf_if_io_dly_0 */
+#define SF_CTRL_SF_CS_DLY_SEL_SHIFT              (0U)
+#define SF_CTRL_SF_CS_DLY_SEL_MASK               (0x3 << SF_CTRL_SF_CS_DLY_SEL_SHIFT)
+#define SF_CTRL_SF_CS2_DLY_SEL_SHIFT             (2U)
+#define SF_CTRL_SF_CS2_DLY_SEL_MASK              (0x3 << SF_CTRL_SF_CS2_DLY_SEL_SHIFT)
+#define SF_CTRL_SF_CLK_OUT_DLY_SEL_SHIFT         (8U)
+#define SF_CTRL_SF_CLK_OUT_DLY_SEL_MASK          (0x3 << SF_CTRL_SF_CLK_OUT_DLY_SEL_SHIFT)
+#define SF_CTRL_SF_DQS_OE_DLY_SEL_SHIFT          (26U)
+#define SF_CTRL_SF_DQS_OE_DLY_SEL_MASK           (0x3 << SF_CTRL_SF_DQS_OE_DLY_SEL_SHIFT)
+#define SF_CTRL_SF_DQS_DI_DLY_SEL_SHIFT          (28U)
+#define SF_CTRL_SF_DQS_DI_DLY_SEL_MASK           (0x3 << SF_CTRL_SF_DQS_DI_DLY_SEL_SHIFT)
+#define SF_CTRL_SF_DQS_DO_DLY_SEL_SHIFT          (30U)
+#define SF_CTRL_SF_DQS_DO_DLY_SEL_MASK           (0x3 << SF_CTRL_SF_DQS_DO_DLY_SEL_SHIFT)
+
+/* 0x34 : sf_if_io_dly_1 */
+#define SF_CTRL_SF_IO_0_OE_DLY_SEL_SHIFT         (0U)
+#define SF_CTRL_SF_IO_0_OE_DLY_SEL_MASK          (0x3 << SF_CTRL_SF_IO_0_OE_DLY_SEL_SHIFT)
+#define SF_CTRL_SF_IO_0_DI_DLY_SEL_SHIFT         (8U)
+#define SF_CTRL_SF_IO_0_DI_DLY_SEL_MASK          (0x3 << SF_CTRL_SF_IO_0_DI_DLY_SEL_SHIFT)
+#define SF_CTRL_SF_IO_0_DO_DLY_SEL_SHIFT         (16U)
+#define SF_CTRL_SF_IO_0_DO_DLY_SEL_MASK          (0x3 << SF_CTRL_SF_IO_0_DO_DLY_SEL_SHIFT)
+
+/* 0x38 : sf_if_io_dly_2 */
+#define SF_CTRL_SF_IO_1_OE_DLY_SEL_SHIFT         (0U)
+#define SF_CTRL_SF_IO_1_OE_DLY_SEL_MASK          (0x3 << SF_CTRL_SF_IO_1_OE_DLY_SEL_SHIFT)
+#define SF_CTRL_SF_IO_1_DI_DLY_SEL_SHIFT         (8U)
+#define SF_CTRL_SF_IO_1_DI_DLY_SEL_MASK          (0x3 << SF_CTRL_SF_IO_1_DI_DLY_SEL_SHIFT)
+#define SF_CTRL_SF_IO_1_DO_DLY_SEL_SHIFT         (16U)
+#define SF_CTRL_SF_IO_1_DO_DLY_SEL_MASK          (0x3 << SF_CTRL_SF_IO_1_DO_DLY_SEL_SHIFT)
+
+/* 0x3C : sf_if_io_dly_3 */
+#define SF_CTRL_SF_IO_2_OE_DLY_SEL_SHIFT         (0U)
+#define SF_CTRL_SF_IO_2_OE_DLY_SEL_MASK          (0x3 << SF_CTRL_SF_IO_2_OE_DLY_SEL_SHIFT)
+#define SF_CTRL_SF_IO_2_DI_DLY_SEL_SHIFT         (8U)
+#define SF_CTRL_SF_IO_2_DI_DLY_SEL_MASK          (0x3 << SF_CTRL_SF_IO_2_DI_DLY_SEL_SHIFT)
+#define SF_CTRL_SF_IO_2_DO_DLY_SEL_SHIFT         (16U)
+#define SF_CTRL_SF_IO_2_DO_DLY_SEL_MASK          (0x3 << SF_CTRL_SF_IO_2_DO_DLY_SEL_SHIFT)
+
+/* 0x40 : sf_if_io_dly_4 */
+#define SF_CTRL_SF_IO_3_OE_DLY_SEL_SHIFT         (0U)
+#define SF_CTRL_SF_IO_3_OE_DLY_SEL_MASK          (0x3 << SF_CTRL_SF_IO_3_OE_DLY_SEL_SHIFT)
+#define SF_CTRL_SF_IO_3_DI_DLY_SEL_SHIFT         (8U)
+#define SF_CTRL_SF_IO_3_DI_DLY_SEL_MASK          (0x3 << SF_CTRL_SF_IO_3_DI_DLY_SEL_SHIFT)
+#define SF_CTRL_SF_IO_3_DO_DLY_SEL_SHIFT         (16U)
+#define SF_CTRL_SF_IO_3_DO_DLY_SEL_MASK          (0x3 << SF_CTRL_SF_IO_3_DO_DLY_SEL_SHIFT)
+
+/* 0x44 : sf_reserved */
+#define SF_CTRL_SF_RESERVED_SHIFT                (0U)
+#define SF_CTRL_SF_RESERVED_MASK                 (0xffffffffL << SF_CTRL_SF_RESERVED_SHIFT)
+
+/* 0x48 : sf2_if_io_dly_0 */
+#define SF_CTRL_SF2_CS_DLY_SEL_SHIFT             (0U)
+#define SF_CTRL_SF2_CS_DLY_SEL_MASK              (0x3 << SF_CTRL_SF2_CS_DLY_SEL_SHIFT)
+#define SF_CTRL_SF2_CS2_DLY_SEL_SHIFT            (2U)
+#define SF_CTRL_SF2_CS2_DLY_SEL_MASK             (0x3 << SF_CTRL_SF2_CS2_DLY_SEL_SHIFT)
+#define SF_CTRL_SF2_CLK_OUT_DLY_SEL_SHIFT        (8U)
+#define SF_CTRL_SF2_CLK_OUT_DLY_SEL_MASK         (0x3 << SF_CTRL_SF2_CLK_OUT_DLY_SEL_SHIFT)
+#define SF_CTRL_SF2_DQS_OE_DLY_SEL_SHIFT         (26U)
+#define SF_CTRL_SF2_DQS_OE_DLY_SEL_MASK          (0x3 << SF_CTRL_SF2_DQS_OE_DLY_SEL_SHIFT)
+#define SF_CTRL_SF2_DQS_DI_DLY_SEL_SHIFT         (28U)
+#define SF_CTRL_SF2_DQS_DI_DLY_SEL_MASK          (0x3 << SF_CTRL_SF2_DQS_DI_DLY_SEL_SHIFT)
+#define SF_CTRL_SF2_DQS_DO_DLY_SEL_SHIFT         (30U)
+#define SF_CTRL_SF2_DQS_DO_DLY_SEL_MASK          (0x3 << SF_CTRL_SF2_DQS_DO_DLY_SEL_SHIFT)
+
+/* 0x4C : sf2_if_io_dly_1 */
+#define SF_CTRL_SF2_IO_0_OE_DLY_SEL_SHIFT        (0U)
+#define SF_CTRL_SF2_IO_0_OE_DLY_SEL_MASK         (0x3 << SF_CTRL_SF2_IO_0_OE_DLY_SEL_SHIFT)
+#define SF_CTRL_SF2_IO_0_DI_DLY_SEL_SHIFT        (8U)
+#define SF_CTRL_SF2_IO_0_DI_DLY_SEL_MASK         (0x3 << SF_CTRL_SF2_IO_0_DI_DLY_SEL_SHIFT)
+#define SF_CTRL_SF2_IO_0_DO_DLY_SEL_SHIFT        (16U)
+#define SF_CTRL_SF2_IO_0_DO_DLY_SEL_MASK         (0x3 << SF_CTRL_SF2_IO_0_DO_DLY_SEL_SHIFT)
+
+/* 0x50 : sf2_if_io_dly_2 */
+#define SF_CTRL_SF2_IO_1_OE_DLY_SEL_SHIFT        (0U)
+#define SF_CTRL_SF2_IO_1_OE_DLY_SEL_MASK         (0x3 << SF_CTRL_SF2_IO_1_OE_DLY_SEL_SHIFT)
+#define SF_CTRL_SF2_IO_1_DI_DLY_SEL_SHIFT        (8U)
+#define SF_CTRL_SF2_IO_1_DI_DLY_SEL_MASK         (0x3 << SF_CTRL_SF2_IO_1_DI_DLY_SEL_SHIFT)
+#define SF_CTRL_SF2_IO_1_DO_DLY_SEL_SHIFT        (16U)
+#define SF_CTRL_SF2_IO_1_DO_DLY_SEL_MASK         (0x3 << SF_CTRL_SF2_IO_1_DO_DLY_SEL_SHIFT)
+
+/* 0x54 : sf2_if_io_dly_3 */
+#define SF_CTRL_SF2_IO_2_OE_DLY_SEL_SHIFT        (0U)
+#define SF_CTRL_SF2_IO_2_OE_DLY_SEL_MASK         (0x3 << SF_CTRL_SF2_IO_2_OE_DLY_SEL_SHIFT)
+#define SF_CTRL_SF2_IO_2_DI_DLY_SEL_SHIFT        (8U)
+#define SF_CTRL_SF2_IO_2_DI_DLY_SEL_MASK         (0x3 << SF_CTRL_SF2_IO_2_DI_DLY_SEL_SHIFT)
+#define SF_CTRL_SF2_IO_2_DO_DLY_SEL_SHIFT        (16U)
+#define SF_CTRL_SF2_IO_2_DO_DLY_SEL_MASK         (0x3 << SF_CTRL_SF2_IO_2_DO_DLY_SEL_SHIFT)
+
+/* 0x58 : sf2_if_io_dly_4 */
+#define SF_CTRL_SF2_IO_3_OE_DLY_SEL_SHIFT        (0U)
+#define SF_CTRL_SF2_IO_3_OE_DLY_SEL_MASK         (0x3 << SF_CTRL_SF2_IO_3_OE_DLY_SEL_SHIFT)
+#define SF_CTRL_SF2_IO_3_DI_DLY_SEL_SHIFT        (8U)
+#define SF_CTRL_SF2_IO_3_DI_DLY_SEL_MASK         (0x3 << SF_CTRL_SF2_IO_3_DI_DLY_SEL_SHIFT)
+#define SF_CTRL_SF2_IO_3_DO_DLY_SEL_SHIFT        (16U)
+#define SF_CTRL_SF2_IO_3_DO_DLY_SEL_MASK         (0x3 << SF_CTRL_SF2_IO_3_DO_DLY_SEL_SHIFT)
+
+/* 0x5C : sf3_if_io_dly_0 */
+#define SF_CTRL_SF3_CS_DLY_SEL_SHIFT             (0U)
+#define SF_CTRL_SF3_CS_DLY_SEL_MASK              (0x3 << SF_CTRL_SF3_CS_DLY_SEL_SHIFT)
+#define SF_CTRL_SF3_CS2_DLY_SEL_SHIFT            (2U)
+#define SF_CTRL_SF3_CS2_DLY_SEL_MASK             (0x3 << SF_CTRL_SF3_CS2_DLY_SEL_SHIFT)
+#define SF_CTRL_SF3_CLK_OUT_DLY_SEL_SHIFT        (8U)
+#define SF_CTRL_SF3_CLK_OUT_DLY_SEL_MASK         (0x3 << SF_CTRL_SF3_CLK_OUT_DLY_SEL_SHIFT)
+#define SF_CTRL_SF3_DQS_OE_DLY_SEL_SHIFT         (26U)
+#define SF_CTRL_SF3_DQS_OE_DLY_SEL_MASK          (0x3 << SF_CTRL_SF3_DQS_OE_DLY_SEL_SHIFT)
+#define SF_CTRL_SF3_DQS_DI_DLY_SEL_SHIFT         (28U)
+#define SF_CTRL_SF3_DQS_DI_DLY_SEL_MASK          (0x3 << SF_CTRL_SF3_DQS_DI_DLY_SEL_SHIFT)
+#define SF_CTRL_SF3_DQS_DO_DLY_SEL_SHIFT         (30U)
+#define SF_CTRL_SF3_DQS_DO_DLY_SEL_MASK          (0x3 << SF_CTRL_SF3_DQS_DO_DLY_SEL_SHIFT)
+
+/* 0x60 : sf3_if_io_dly_1 */
+#define SF_CTRL_SF3_IO_0_OE_DLY_SEL_SHIFT        (0U)
+#define SF_CTRL_SF3_IO_0_OE_DLY_SEL_MASK         (0x3 << SF_CTRL_SF3_IO_0_OE_DLY_SEL_SHIFT)
+#define SF_CTRL_SF3_IO_0_DI_DLY_SEL_SHIFT        (8U)
+#define SF_CTRL_SF3_IO_0_DI_DLY_SEL_MASK         (0x3 << SF_CTRL_SF3_IO_0_DI_DLY_SEL_SHIFT)
+#define SF_CTRL_SF3_IO_0_DO_DLY_SEL_SHIFT        (16U)
+#define SF_CTRL_SF3_IO_0_DO_DLY_SEL_MASK         (0x3 << SF_CTRL_SF3_IO_0_DO_DLY_SEL_SHIFT)
+
+/* 0x64 : sf3_if_io_dly_2 */
+#define SF_CTRL_SF3_IO_1_OE_DLY_SEL_SHIFT        (0U)
+#define SF_CTRL_SF3_IO_1_OE_DLY_SEL_MASK         (0x3 << SF_CTRL_SF3_IO_1_OE_DLY_SEL_SHIFT)
+#define SF_CTRL_SF3_IO_1_DI_DLY_SEL_SHIFT        (8U)
+#define SF_CTRL_SF3_IO_1_DI_DLY_SEL_MASK         (0x3 << SF_CTRL_SF3_IO_1_DI_DLY_SEL_SHIFT)
+#define SF_CTRL_SF3_IO_1_DO_DLY_SEL_SHIFT        (16U)
+#define SF_CTRL_SF3_IO_1_DO_DLY_SEL_MASK         (0x3 << SF_CTRL_SF3_IO_1_DO_DLY_SEL_SHIFT)
+
+/* 0x68 : sf3_if_io_dly_3 */
+#define SF_CTRL_SF3_IO_2_OE_DLY_SEL_SHIFT        (0U)
+#define SF_CTRL_SF3_IO_2_OE_DLY_SEL_MASK         (0x3 << SF_CTRL_SF3_IO_2_OE_DLY_SEL_SHIFT)
+#define SF_CTRL_SF3_IO_2_DI_DLY_SEL_SHIFT        (8U)
+#define SF_CTRL_SF3_IO_2_DI_DLY_SEL_MASK         (0x3 << SF_CTRL_SF3_IO_2_DI_DLY_SEL_SHIFT)
+#define SF_CTRL_SF3_IO_2_DO_DLY_SEL_SHIFT        (16U)
+#define SF_CTRL_SF3_IO_2_DO_DLY_SEL_MASK         (0x3 << SF_CTRL_SF3_IO_2_DO_DLY_SEL_SHIFT)
+
+/* 0x6C : sf3_if_io_dly_4 */
+#define SF_CTRL_SF3_IO_3_OE_DLY_SEL_SHIFT        (0U)
+#define SF_CTRL_SF3_IO_3_OE_DLY_SEL_MASK         (0x3 << SF_CTRL_SF3_IO_3_OE_DLY_SEL_SHIFT)
+#define SF_CTRL_SF3_IO_3_DI_DLY_SEL_SHIFT        (8U)
+#define SF_CTRL_SF3_IO_3_DI_DLY_SEL_MASK         (0x3 << SF_CTRL_SF3_IO_3_DI_DLY_SEL_SHIFT)
+#define SF_CTRL_SF3_IO_3_DO_DLY_SEL_SHIFT        (16U)
+#define SF_CTRL_SF3_IO_3_DO_DLY_SEL_MASK         (0x3 << SF_CTRL_SF3_IO_3_DO_DLY_SEL_SHIFT)
+
+/* 0x70 : sf_ctrl_2 */
+#define SF_CTRL_SF_IF_PAD_SEL_SHIFT              (0U)
+#define SF_CTRL_SF_IF_PAD_SEL_MASK               (0x3 << SF_CTRL_SF_IF_PAD_SEL_SHIFT)
+#define SF_CTRL_SF_IF_PAD_SEL_LOCK               BIT(3)
+#define SF_CTRL_SF_IF_DTR_EN                     BIT(4)
+#define SF_CTRL_SF_IF_DQS_EN                     BIT(5)
+#define SF_CTRL_SF_IF_TRIG_WR_PROT               BIT(6)
+#define SF_CTRL_SF_ID_OFFSET_LOCK                BIT(7)
+#define SF_CTRL_SF_AHB2SIF_REMAP_LOCK            BIT(25)
+#define SF_CTRL_SF_AHB2SIF_REMAP_SHIFT           (26U)
+#define SF_CTRL_SF_AHB2SIF_REMAP_MASK            (0x3 << SF_CTRL_SF_AHB2SIF_REMAP_SHIFT)
+#define SF_CTRL_SF_IF_BK_SWAP                    BIT(28)
+#define SF_CTRL_SF_IF_BK2_MODE                   BIT(29)
+#define SF_CTRL_SF_IF_BK2_EN                     BIT(30)
+#define SF_CTRL_SF_IF_0_BK_SEL                   BIT(31)
+
+/* 0x74 : sf_ctrl_3 */
+#define SF_CTRL_SF_CMDS_2_WRAP_LEN_SHIFT         (0U)
+#define SF_CTRL_SF_CMDS_2_WRAP_LEN_MASK          (0xf << SF_CTRL_SF_CMDS_2_WRAP_LEN_SHIFT)
+#define SF_CTRL_SF_CMDS_2_EN                     BIT(4)
+#define SF_CTRL_SF_CMDS_2_BT_DLY_SHIFT           (5U)
+#define SF_CTRL_SF_CMDS_2_BT_DLY_MASK            (0x7 << SF_CTRL_SF_CMDS_2_BT_DLY_SHIFT)
+#define SF_CTRL_SF_CMDS_2_BT_EN                  BIT(8)
+#define SF_CTRL_SF_CMDS_2_WRAP_Q_INI             BIT(9)
+#define SF_CTRL_SF_CMDS_2_WRAP_MODE_SHIFT        (10U)
+#define SF_CTRL_SF_CMDS_2_WRAP_MODE_MASK         (0x3 << SF_CTRL_SF_CMDS_2_WRAP_MODE_SHIFT)
+#define SF_CTRL_SF_CMDS_2_WRAP_Q                 BIT(12)
+#define SF_CTRL_SF_CMDS_1_WRAP_LEN_SHIFT         (13U)
+#define SF_CTRL_SF_CMDS_1_WRAP_LEN_MASK          (0xf << SF_CTRL_SF_CMDS_1_WRAP_LEN_SHIFT)
+#define SF_CTRL_SF_CMDS_1_EN                     BIT(17)
+#define SF_CTRL_SF_CMDS_1_WRAP_MODE_SHIFT        (18U)
+#define SF_CTRL_SF_CMDS_1_WRAP_MODE_MASK         (0x3 << SF_CTRL_SF_CMDS_1_WRAP_MODE_SHIFT)
+#define SF_CTRL_SF_CMDS_CORE_EN                  BIT(20)
+#define SF_CTRL_SF_IF_1_ACK_LAT_SHIFT            (29U)
+#define SF_CTRL_SF_IF_1_ACK_LAT_MASK             (0x7 << SF_CTRL_SF_IF_1_ACK_LAT_SHIFT)
+
+/* 0x78 : sf_if_iahb_3 */
+#define SF_CTRL_SF_IF_2_DMY_BYTE_SHIFT           (12U)
+#define SF_CTRL_SF_IF_2_DMY_BYTE_MASK            (0x1f << SF_CTRL_SF_IF_2_DMY_BYTE_SHIFT)
+#define SF_CTRL_SF_IF_2_ADR_BYTE_SHIFT           (17U)
+#define SF_CTRL_SF_IF_2_ADR_BYTE_MASK            (0x7 << SF_CTRL_SF_IF_2_ADR_BYTE_SHIFT)
+#define SF_CTRL_SF_IF_2_CMD_BYTE_SHIFT           (20U)
+#define SF_CTRL_SF_IF_2_CMD_BYTE_MASK            (0x7 << SF_CTRL_SF_IF_2_CMD_BYTE_SHIFT)
+#define SF_CTRL_SF_IF_2_DAT_RW                   BIT(23)
+#define SF_CTRL_SF_IF_2_DAT_EN                   BIT(24)
+#define SF_CTRL_SF_IF_2_DMY_EN                   BIT(25)
+#define SF_CTRL_SF_IF_2_ADR_EN                   BIT(26)
+#define SF_CTRL_SF_IF_2_CMD_EN                   BIT(27)
+#define SF_CTRL_SF_IF_2_SPI_MODE_SHIFT           (28U)
+#define SF_CTRL_SF_IF_2_SPI_MODE_MASK            (0x7 << SF_CTRL_SF_IF_2_SPI_MODE_SHIFT)
+#define SF_CTRL_SF_IF_2_QPI_MODE_EN              BIT(31)
+
+/* 0x7C : sf_if_iahb_4 */
+#define SF_CTRL_SF_IF_2_CMD_BUF_0_SHIFT          (0U)
+#define SF_CTRL_SF_IF_2_CMD_BUF_0_MASK           (0xffffffffL << SF_CTRL_SF_IF_2_CMD_BUF_0_SHIFT)
+
+/* 0x80 : sf_if_iahb_5 */
+#define SF_CTRL_SF_IF_2_CMD_BUF_1_SHIFT          (0U)
+#define SF_CTRL_SF_IF_2_CMD_BUF_1_MASK           (0xffffffffL << SF_CTRL_SF_IF_2_CMD_BUF_1_SHIFT)
+
+/* 0x84 : sf_if_iahb_6 */
+#define SF_CTRL_SF_IF_3_ADR_BYTE_SHIFT           (17U)
+#define SF_CTRL_SF_IF_3_ADR_BYTE_MASK            (0x7 << SF_CTRL_SF_IF_3_ADR_BYTE_SHIFT)
+#define SF_CTRL_SF_IF_3_CMD_BYTE_SHIFT           (20U)
+#define SF_CTRL_SF_IF_3_CMD_BYTE_MASK            (0x7 << SF_CTRL_SF_IF_3_CMD_BYTE_SHIFT)
+#define SF_CTRL_SF_IF_3_ADR_EN                   BIT(26)
+#define SF_CTRL_SF_IF_3_CMD_EN                   BIT(27)
+#define SF_CTRL_SF_IF_3_SPI_MODE_SHIFT           (28U)
+#define SF_CTRL_SF_IF_3_SPI_MODE_MASK            (0x7 << SF_CTRL_SF_IF_3_SPI_MODE_SHIFT)
+#define SF_CTRL_SF_IF_3_QPI_MODE_EN              BIT(31)
+
+/* 0x88 : sf_if_iahb_7 */
+#define SF_CTRL_SF_IF_3_CMD_BUF_0_SHIFT          (0U)
+#define SF_CTRL_SF_IF_3_CMD_BUF_0_MASK           (0xffffffffL << SF_CTRL_SF_IF_3_CMD_BUF_0_SHIFT)
+
+/* 0x8C : sf_if_iahb_8 */
+#define SF_CTRL_SF_IF_3_CMD_BUF_1_SHIFT          (0U)
+#define SF_CTRL_SF_IF_3_CMD_BUF_1_MASK           (0xffffffffL << SF_CTRL_SF_IF_3_CMD_BUF_1_SHIFT)
+
+/* 0x90 : sf_if_iahb_9 */
+#define SF_CTRL_SF_IF_4_DMY_BYTE_SHIFT           (12U)
+#define SF_CTRL_SF_IF_4_DMY_BYTE_MASK            (0x1f << SF_CTRL_SF_IF_4_DMY_BYTE_SHIFT)
+#define SF_CTRL_SF_IF_4_ADR_BYTE_SHIFT           (17U)
+#define SF_CTRL_SF_IF_4_ADR_BYTE_MASK            (0x7 << SF_CTRL_SF_IF_4_ADR_BYTE_SHIFT)
+#define SF_CTRL_SF_IF_4_CMD_BYTE_SHIFT           (20U)
+#define SF_CTRL_SF_IF_4_CMD_BYTE_MASK            (0x7 << SF_CTRL_SF_IF_4_CMD_BYTE_SHIFT)
+#define SF_CTRL_SF_IF_4_DAT_RW                   BIT(23)
+#define SF_CTRL_SF_IF_4_DAT_EN                   BIT(24)
+#define SF_CTRL_SF_IF_4_DMY_EN                   BIT(25)
+#define SF_CTRL_SF_IF_4_ADR_EN                   BIT(26)
+#define SF_CTRL_SF_IF_4_CMD_EN                   BIT(27)
+#define SF_CTRL_SF_IF_4_SPI_MODE_SHIFT           (28U)
+#define SF_CTRL_SF_IF_4_SPI_MODE_MASK            (0x7 << SF_CTRL_SF_IF_4_SPI_MODE_SHIFT)
+#define SF_CTRL_SF_IF_4_QPI_MODE_EN              BIT(31)
+
+/* 0x94 : sf_if_iahb_10 */
+#define SF_CTRL_SF_IF_4_CMD_BUF_0_SHIFT          (0U)
+#define SF_CTRL_SF_IF_4_CMD_BUF_0_MASK           (0xffffffffL << SF_CTRL_SF_IF_4_CMD_BUF_0_SHIFT)
+
+/* 0x98 : sf_if_iahb_11 */
+#define SF_CTRL_SF_IF_4_CMD_BUF_1_SHIFT          (0U)
+#define SF_CTRL_SF_IF_4_CMD_BUF_1_MASK           (0xffffffffL << SF_CTRL_SF_IF_4_CMD_BUF_1_SHIFT)
+
+/* 0x9C : sf_if_iahb_12 */
+#define SF_CTRL_SF2_CLK_SF_RX_INV_SEL            BIT(2)
+#define SF_CTRL_SF2_CLK_SF_RX_INV_SRC            BIT(3)
+#define SF_CTRL_SF2_CLK_OUT_INV_SEL              BIT(4)
+#define SF_CTRL_SF3_CLK_OUT_INV_SEL              BIT(5)
+#define SF_CTRL_SF2_IF_READ_DLY_N_SHIFT          (8U)
+#define SF_CTRL_SF2_IF_READ_DLY_N_MASK           (0x7 << SF_CTRL_SF2_IF_READ_DLY_N_SHIFT)
+#define SF_CTRL_SF2_IF_READ_DLY_EN               BIT(11)
+#define SF_CTRL_SF2_IF_READ_DLY_SRC              BIT(12)
+
+/* 0xA0 : sf_id0_offset */
+#define SF_CTRL_SF_ID0_OFFSET_SHIFT              (0U)
+#define SF_CTRL_SF_ID0_OFFSET_MASK               (0xfffffff << SF_CTRL_SF_ID0_OFFSET_SHIFT)
+
+/* 0xA4 : sf_id1_offset */
+#define SF_CTRL_SF_ID1_OFFSET_SHIFT              (0U)
+#define SF_CTRL_SF_ID1_OFFSET_MASK               (0xfffffff << SF_CTRL_SF_ID1_OFFSET_SHIFT)
+
+/* 0xA8 : sf_bk2_id0_offset */
+#define SF_CTRL_SF_BK2_ID0_OFFSET_SHIFT          (0U)
+#define SF_CTRL_SF_BK2_ID0_OFFSET_MASK           (0xfffffff << SF_CTRL_SF_BK2_ID0_OFFSET_SHIFT)
+
+/* 0xAC : sf_bk2_id1_offset */
+#define SF_CTRL_SF_BK2_ID1_OFFSET_SHIFT          (0U)
+#define SF_CTRL_SF_BK2_ID1_OFFSET_MASK           (0xfffffff << SF_CTRL_SF_BK2_ID1_OFFSET_SHIFT)
+
+/* 0xB0 : sf_dbg */
+#define SF_CTRL_SF_AUTOLOAD_ST_SHIFT             (0U)
+#define SF_CTRL_SF_AUTOLOAD_ST_MASK              (0x1f << SF_CTRL_SF_AUTOLOAD_ST_SHIFT)
+#define SF_CTRL_SF_AUTOLOAD_ST_DONE              BIT(5)
+
+/* 0xC0 : sf_if2_ctrl_0 */
+#define SF_CTRL_SF_CLK_SF_IF2_RX_INV_SEL         BIT(2)
+#define SF_CTRL_SF_IF2_READ_DLY_N_SHIFT          (8U)
+#define SF_CTRL_SF_IF2_READ_DLY_N_MASK           (0x7 << SF_CTRL_SF_IF2_READ_DLY_N_SHIFT)
+#define SF_CTRL_SF_IF2_READ_DLY_EN               BIT(11)
+#define SF_CTRL_SF_IF2_INT                       BIT(16)
+#define SF_CTRL_SF_IF2_INT_CLR                   BIT(17)
+#define SF_CTRL_SF_IF2_INT_SET                   BIT(18)
+#define SF_CTRL_SF_IF2_REPLACE_SF1               BIT(23)
+#define SF_CTRL_SF_IF2_REPLACE_SF2               BIT(24)
+#define SF_CTRL_SF_IF2_REPLACE_SF3               BIT(25)
+#define SF_CTRL_SF_IF2_PAD_SEL_SHIFT             (26U)
+#define SF_CTRL_SF_IF2_PAD_SEL_MASK              (0x3 << SF_CTRL_SF_IF2_PAD_SEL_SHIFT)
+#define SF_CTRL_SF_IF2_BK_SWAP                   BIT(28)
+#define SF_CTRL_SF_IF2_BK2_MODE                  BIT(29)
+#define SF_CTRL_SF_IF2_BK2_EN                    BIT(30)
+#define SF_CTRL_SF_IF2_BK_SEL                    BIT(31)
+
+/* 0xC4 : sf_if2_ctrl_1 */
+#define SF_CTRL_SF_IF2_SR_PAT_MASK_SHIFT         (0U)
+#define SF_CTRL_SF_IF2_SR_PAT_MASK_MASK          (0xff << SF_CTRL_SF_IF2_SR_PAT_MASK_SHIFT)
+#define SF_CTRL_SF_IF2_SR_PAT_SHIFT              (8U)
+#define SF_CTRL_SF_IF2_SR_PAT_MASK               (0xff << SF_CTRL_SF_IF2_SR_PAT_SHIFT)
+#define SF_CTRL_SF_IF2_SR_INT                    BIT(16)
+#define SF_CTRL_SF_IF2_SR_INT_EN                 BIT(17)
+#define SF_CTRL_SF_IF2_SR_INT_SET                BIT(18)
+#define SF_CTRL_SF_IF2_ACK_LAT_SHIFT             (20U)
+#define SF_CTRL_SF_IF2_ACK_LAT_MASK              (0x7 << SF_CTRL_SF_IF2_ACK_LAT_SHIFT)
+#define SF_CTRL_SF_IF2_REG_HOLD                  BIT(24)
+#define SF_CTRL_SF_IF2_REG_WP                    BIT(25)
+#define SF_CTRL_SF_IF2_FN_SEL                    BIT(28)
+#define SF_CTRL_SF_IF2_EN                        BIT(29)
+
+/* 0xC8 : sf_if2_sahb_0 */
+#define SF_CTRL_SF_IF2_BUSY                      BIT(0)
+#define SF_CTRL_SF_IF2_0_TRIG                    BIT(1)
+#define SF_CTRL_SF_IF2_0_DAT_BYTE_SHIFT          (2U)
+#define SF_CTRL_SF_IF2_0_DAT_BYTE_MASK           (0x3ff << SF_CTRL_SF_IF2_0_DAT_BYTE_SHIFT)
+#define SF_CTRL_SF_IF2_0_DMY_BYTE_SHIFT          (12U)
+#define SF_CTRL_SF_IF2_0_DMY_BYTE_MASK           (0x1f << SF_CTRL_SF_IF2_0_DMY_BYTE_SHIFT)
+#define SF_CTRL_SF_IF2_0_ADR_BYTE_SHIFT          (17U)
+#define SF_CTRL_SF_IF2_0_ADR_BYTE_MASK           (0x7 << SF_CTRL_SF_IF2_0_ADR_BYTE_SHIFT)
+#define SF_CTRL_SF_IF2_0_CMD_BYTE_SHIFT          (20U)
+#define SF_CTRL_SF_IF2_0_CMD_BYTE_MASK           (0x7 << SF_CTRL_SF_IF2_0_CMD_BYTE_SHIFT)
+#define SF_CTRL_SF_IF2_0_DAT_RW                  BIT(23)
+#define SF_CTRL_SF_IF2_0_DAT_EN                  BIT(24)
+#define SF_CTRL_SF_IF2_0_DMY_EN                  BIT(25)
+#define SF_CTRL_SF_IF2_0_ADR_EN                  BIT(26)
+#define SF_CTRL_SF_IF2_0_CMD_EN                  BIT(27)
+#define SF_CTRL_SF_IF2_0_SPI_MODE_SHIFT          (28U)
+#define SF_CTRL_SF_IF2_0_SPI_MODE_MASK           (0x7 << SF_CTRL_SF_IF2_0_SPI_MODE_SHIFT)
+#define SF_CTRL_SF_IF2_0_QPI_MODE_EN             BIT(31)
+
+/* 0xCC : sf_if2_sahb_1 */
+#define SF_CTRL_SF_IF2_0_CMD_BUF_0_SHIFT         (0U)
+#define SF_CTRL_SF_IF2_0_CMD_BUF_0_MASK          (0xffffffffL << SF_CTRL_SF_IF2_0_CMD_BUF_0_SHIFT)
+
+/* 0xD0 : sf_if2_sahb_2 */
+#define SF_CTRL_SF_IF2_0_CMD_BUF_1_SHIFT         (0U)
+#define SF_CTRL_SF_IF2_0_CMD_BUF_1_MASK          (0xffffffffL << SF_CTRL_SF_IF2_0_CMD_BUF_1_SHIFT)
+
+/* 0x100 : sf_ctrl_prot_en_rd */
+#define SF_CTRL_ID0_EN_RD                        BIT(1)
+#define SF_CTRL_ID1_EN_RD                        BIT(2)
+#define SF_CTRL_SF_SEC_TZSID_LOCK                BIT(28)
+#define SF_CTRL_SF_IF2_0_TRIG_WR_LOCK            BIT(29)
+#define SF_CTRL_SF_IF_0_TRIG_WR_LOCK             BIT(30)
+#define SF_CTRL_SF_DBG_DIS                       BIT(31)
+
+/* 0x104 : sf_ctrl_prot_en */
+#define SF_CTRL_ID0_EN                           BIT(1)
+#define SF_CTRL_ID1_EN                           BIT(2)
+
+/* 0x200 : sf_aes_key_r0_0 */
+#define SF_CTRL_SF_AES_KEY_R0_0_SHIFT            (0U)
+#define SF_CTRL_SF_AES_KEY_R0_0_MASK             (0xffffffffL << SF_CTRL_SF_AES_KEY_R0_0_SHIFT)
+
+/* 0x204 : sf_aes_key_r0_1 */
+#define SF_CTRL_SF_AES_KEY_R0_1_SHIFT            (0U)
+#define SF_CTRL_SF_AES_KEY_R0_1_MASK             (0xffffffffL << SF_CTRL_SF_AES_KEY_R0_1_SHIFT)
+
+/* 0x208 : sf_aes_key_r0_2 */
+#define SF_CTRL_SF_AES_KEY_R0_2_SHIFT            (0U)
+#define SF_CTRL_SF_AES_KEY_R0_2_MASK             (0xffffffffL << SF_CTRL_SF_AES_KEY_R0_2_SHIFT)
+
+/* 0x20C : sf_aes_key_r0_3 */
+#define SF_CTRL_SF_AES_KEY_R0_3_SHIFT            (0U)
+#define SF_CTRL_SF_AES_KEY_R0_3_MASK             (0xffffffffL << SF_CTRL_SF_AES_KEY_R0_3_SHIFT)
+
+/* 0x210 : sf_aes_key_r0_4 */
+#define SF_CTRL_SF_AES_KEY_R0_4_SHIFT            (0U)
+#define SF_CTRL_SF_AES_KEY_R0_4_MASK             (0xffffffffL << SF_CTRL_SF_AES_KEY_R0_4_SHIFT)
+
+/* 0x214 : sf_aes_key_r0_5 */
+#define SF_CTRL_SF_AES_KEY_R0_5_SHIFT            (0U)
+#define SF_CTRL_SF_AES_KEY_R0_5_MASK             (0xffffffffL << SF_CTRL_SF_AES_KEY_R0_5_SHIFT)
+
+/* 0x218 : sf_aes_key_r0_6 */
+#define SF_CTRL_SF_AES_KEY_R0_6_SHIFT            (0U)
+#define SF_CTRL_SF_AES_KEY_R0_6_MASK             (0xffffffffL << SF_CTRL_SF_AES_KEY_R0_6_SHIFT)
+
+/* 0x21C : sf_aes_key_r0_7 */
+#define SF_CTRL_SF_AES_KEY_R0_7_SHIFT            (0U)
+#define SF_CTRL_SF_AES_KEY_R0_7_MASK             (0xffffffffL << SF_CTRL_SF_AES_KEY_R0_7_SHIFT)
+
+/* 0x220 : sf_aes_iv_r0_w0 */
+#define SF_CTRL_SF_AES_IV_R0_W0_SHIFT            (0U)
+#define SF_CTRL_SF_AES_IV_R0_W0_MASK             (0xffffffffL << SF_CTRL_SF_AES_IV_R0_W0_SHIFT)
+
+/* 0x224 : sf_aes_iv_r0_w1 */
+#define SF_CTRL_SF_AES_IV_R0_W1_SHIFT            (0U)
+#define SF_CTRL_SF_AES_IV_R0_W1_MASK             (0xffffffffL << SF_CTRL_SF_AES_IV_R0_W1_SHIFT)
+
+/* 0x228 : sf_aes_iv_r0_w2 */
+#define SF_CTRL_SF_AES_IV_R0_W2_SHIFT            (0U)
+#define SF_CTRL_SF_AES_IV_R0_W2_MASK             (0xffffffffL << SF_CTRL_SF_AES_IV_R0_W2_SHIFT)
+
+/* 0x22C : sf_aes_iv_r0_w3 */
+#define SF_CTRL_SF_AES_IV_R0_W3_SHIFT            (0U)
+#define SF_CTRL_SF_AES_IV_R0_W3_MASK             (0xffffffffL << SF_CTRL_SF_AES_IV_R0_W3_SHIFT)
+
+/* 0x230 : sf_aes_r0_start */
+#define SF_CTRL_SF_AES_REGION_R0_START_SHIFT     (0U)
+#define SF_CTRL_SF_AES_REGION_R0_START_MASK      (0x7ffff << SF_CTRL_SF_AES_REGION_R0_START_SHIFT)
+#define SF_CTRL_SF_AES_REGION_R0_HW_KEY_EN       BIT(29)
+#define SF_CTRL_SF_AES_REGION_R0_EN              BIT(30)
+#define SF_CTRL_SF_AES_REGION_R0_LOCK            BIT(31)
+
+/* 0x234 : sf_aes_r0_end */
+#define SF_CTRL_SF_AES_REGION_R0_END_SHIFT       (0U)
+#define SF_CTRL_SF_AES_REGION_R0_END_MASK        (0x7ffff << SF_CTRL_SF_AES_REGION_R0_END_SHIFT)
+
+/* 0x280 : sf_aes_key_r1_0 */
+#define SF_CTRL_SF_AES_KEY_R1_0_SHIFT            (0U)
+#define SF_CTRL_SF_AES_KEY_R1_0_MASK             (0xffffffffL << SF_CTRL_SF_AES_KEY_R1_0_SHIFT)
+
+/* 0x284 : sf_aes_key_r1_1 */
+#define SF_CTRL_SF_AES_KEY_R1_1_SHIFT            (0U)
+#define SF_CTRL_SF_AES_KEY_R1_1_MASK             (0xffffffffL << SF_CTRL_SF_AES_KEY_R1_1_SHIFT)
+
+/* 0x288 : sf_aes_key_r1_2 */
+#define SF_CTRL_SF_AES_KEY_R1_2_SHIFT            (0U)
+#define SF_CTRL_SF_AES_KEY_R1_2_MASK             (0xffffffffL << SF_CTRL_SF_AES_KEY_R1_2_SHIFT)
+
+/* 0x28C : sf_aes_key_r1_3 */
+#define SF_CTRL_SF_AES_KEY_R1_3_SHIFT            (0U)
+#define SF_CTRL_SF_AES_KEY_R1_3_MASK             (0xffffffffL << SF_CTRL_SF_AES_KEY_R1_3_SHIFT)
+
+/* 0x290 : sf_aes_key_r1_4 */
+#define SF_CTRL_SF_AES_KEY_R1_4_SHIFT            (0U)
+#define SF_CTRL_SF_AES_KEY_R1_4_MASK             (0xffffffffL << SF_CTRL_SF_AES_KEY_R1_4_SHIFT)
+
+/* 0x294 : sf_aes_key_r1_5 */
+#define SF_CTRL_SF_AES_KEY_R1_5_SHIFT            (0U)
+#define SF_CTRL_SF_AES_KEY_R1_5_MASK             (0xffffffffL << SF_CTRL_SF_AES_KEY_R1_5_SHIFT)
+
+/* 0x298 : sf_aes_key_r1_6 */
+#define SF_CTRL_SF_AES_KEY_R1_6_SHIFT            (0U)
+#define SF_CTRL_SF_AES_KEY_R1_6_MASK             (0xffffffffL << SF_CTRL_SF_AES_KEY_R1_6_SHIFT)
+
+/* 0x29C : sf_aes_key_r1_7 */
+#define SF_CTRL_SF_AES_KEY_R1_7_SHIFT            (0U)
+#define SF_CTRL_SF_AES_KEY_R1_7_MASK             (0xffffffffL << SF_CTRL_SF_AES_KEY_R1_7_SHIFT)
+
+/* 0x2A0 : sf_aes_iv_r1_w0 */
+#define SF_CTRL_SF_AES_IV_R1_W0_SHIFT            (0U)
+#define SF_CTRL_SF_AES_IV_R1_W0_MASK             (0xffffffffL << SF_CTRL_SF_AES_IV_R1_W0_SHIFT)
+
+/* 0x2A4 : sf_aes_iv_r1_w1 */
+#define SF_CTRL_SF_AES_IV_R1_W1_SHIFT            (0U)
+#define SF_CTRL_SF_AES_IV_R1_W1_MASK             (0xffffffffL << SF_CTRL_SF_AES_IV_R1_W1_SHIFT)
+
+/* 0x2A8 : sf_aes_iv_r1_w2 */
+#define SF_CTRL_SF_AES_IV_R1_W2_SHIFT            (0U)
+#define SF_CTRL_SF_AES_IV_R1_W2_MASK             (0xffffffffL << SF_CTRL_SF_AES_IV_R1_W2_SHIFT)
+
+/* 0x2AC : sf_aes_iv_r1_w3 */
+#define SF_CTRL_SF_AES_IV_R1_W3_SHIFT            (0U)
+#define SF_CTRL_SF_AES_IV_R1_W3_MASK             (0xffffffffL << SF_CTRL_SF_AES_IV_R1_W3_SHIFT)
+
+/* 0x2B0 : sf_aes_r1_start */
+#define SF_CTRL_SF_AES_R1_START_SHIFT            (0U)
+#define SF_CTRL_SF_AES_R1_START_MASK             (0x7ffff << SF_CTRL_SF_AES_R1_START_SHIFT)
+#define SF_CTRL_SF_AES_R1_HW_KEY_EN              BIT(29)
+#define SF_CTRL_SF_AES_R1_EN                     BIT(30)
+#define SF_CTRL_SF_AES_R1_LOCK                   BIT(31)
+
+/* 0x2B4 : sf_aes_r1_end */
+#define SF_CTRL_SF_AES_R1_END_SHIFT              (0U)
+#define SF_CTRL_SF_AES_R1_END_MASK               (0x7ffff << SF_CTRL_SF_AES_R1_END_SHIFT)
+
+/* 0x300 : sf_aes_key_r2_0 */
+#define SF_CTRL_SF_AES_KEY_R2_0_SHIFT            (0U)
+#define SF_CTRL_SF_AES_KEY_R2_0_MASK             (0xffffffffL << SF_CTRL_SF_AES_KEY_R2_0_SHIFT)
+
+/* 0x304 : sf_aes_key_r2_1 */
+#define SF_CTRL_SF_AES_KEY_R2_1_SHIFT            (0U)
+#define SF_CTRL_SF_AES_KEY_R2_1_MASK             (0xffffffffL << SF_CTRL_SF_AES_KEY_R2_1_SHIFT)
+
+/* 0x308 : sf_aes_key_r2_2 */
+#define SF_CTRL_SF_AES_KEY_R2_2_SHIFT            (0U)
+#define SF_CTRL_SF_AES_KEY_R2_2_MASK             (0xffffffffL << SF_CTRL_SF_AES_KEY_R2_2_SHIFT)
+
+/* 0x30C : sf_aes_key_r2_3 */
+#define SF_CTRL_SF_AES_KEY_R2_3_SHIFT            (0U)
+#define SF_CTRL_SF_AES_KEY_R2_3_MASK             (0xffffffffL << SF_CTRL_SF_AES_KEY_R2_3_SHIFT)
+
+/* 0x310 : sf_aes_key_r2_4 */
+#define SF_CTRL_SF_AES_KEY_R2_4_SHIFT            (0U)
+#define SF_CTRL_SF_AES_KEY_R2_4_MASK             (0xffffffffL << SF_CTRL_SF_AES_KEY_R2_4_SHIFT)
+
+/* 0x314 : sf_aes_key_r2_5 */
+#define SF_CTRL_SF_AES_KEY_R2_5_SHIFT            (0U)
+#define SF_CTRL_SF_AES_KEY_R2_5_MASK             (0xffffffffL << SF_CTRL_SF_AES_KEY_R2_5_SHIFT)
+
+/* 0x318 : sf_aes_key_r2_6 */
+#define SF_CTRL_SF_AES_KEY_R2_6_SHIFT            (0U)
+#define SF_CTRL_SF_AES_KEY_R2_6_MASK             (0xffffffffL << SF_CTRL_SF_AES_KEY_R2_6_SHIFT)
+
+/* 0x31C : sf_aes_key_r2_7 */
+#define SF_CTRL_SF_AES_KEY_R2_7_SHIFT            (0U)
+#define SF_CTRL_SF_AES_KEY_R2_7_MASK             (0xffffffffL << SF_CTRL_SF_AES_KEY_R2_7_SHIFT)
+
+/* 0x320 : sf_aes_iv_r2_w0 */
+#define SF_CTRL_SF_AES_IV_R2_W0_SHIFT            (0U)
+#define SF_CTRL_SF_AES_IV_R2_W0_MASK             (0xffffffffL << SF_CTRL_SF_AES_IV_R2_W0_SHIFT)
+
+/* 0x324 : sf_aes_iv_r2_w1 */
+#define SF_CTRL_SF_AES_IV_R2_W1_SHIFT            (0U)
+#define SF_CTRL_SF_AES_IV_R2_W1_MASK             (0xffffffffL << SF_CTRL_SF_AES_IV_R2_W1_SHIFT)
+
+/* 0x328 : sf_aes_iv_r2_w2 */
+#define SF_CTRL_SF_AES_IV_R2_W2_SHIFT            (0U)
+#define SF_CTRL_SF_AES_IV_R2_W2_MASK             (0xffffffffL << SF_CTRL_SF_AES_IV_R2_W2_SHIFT)
+
+/* 0x32C : sf_aes_iv_r2_w3 */
+#define SF_CTRL_SF_AES_IV_R2_W3_SHIFT            (0U)
+#define SF_CTRL_SF_AES_IV_R2_W3_MASK             (0xffffffffL << SF_CTRL_SF_AES_IV_R2_W3_SHIFT)
+
+/* 0x330 : sf_aes_r2_start */
+#define SF_CTRL_SF_AES_R2_START_SHIFT            (0U)
+#define SF_CTRL_SF_AES_R2_START_MASK             (0x7ffff << SF_CTRL_SF_AES_R2_START_SHIFT)
+#define SF_CTRL_SF_AES_R2_HW_KEY_EN              BIT(29)
+#define SF_CTRL_SF_AES_R2_EN                     BIT(30)
+#define SF_CTRL_SF_AES_R2_LOCK                   BIT(31)
+
+/* 0x334 : sf_aes_r2_end */
+#define SF_CTRL_SF_AES_R2_END_SHIFT              (0U)
+#define SF_CTRL_SF_AES_R2_END_MASK               (0x7ffff << SF_CTRL_SF_AES_R2_END_SHIFT)
+
+/* Register offsets */
+#define SF_CTRL_IF_SAHB_0_OFFSET                 (0x0)/* sf_if_sahb_0 */
+#define SF_CTRL_IF_SAHB_1_OFFSET                 (0x4)/* sf_if_sahb_1 */
+#define SF_CTRL_IF_SAHB_2_OFFSET                 (0x8)/* sf_if_sahb_2 */
+
+/* 0x0 : sf_if_sahb_0 */
+#define SF_CTRL_IF_BUSY                          BIT(0)
+#define SF_CTRL_IF_0_TRIG                        BIT(1)
+#define SF_CTRL_IF_0_DAT_BYTE_SHIFT              (2U)
+#define SF_CTRL_IF_0_DAT_BYTE_MASK               (0x3ff << SF_CTRL_IF_0_DAT_BYTE_SHIFT)
+#define SF_CTRL_IF_0_DMY_BYTE_SHIFT              (12U)
+#define SF_CTRL_IF_0_DMY_BYTE_MASK               (0x1f << SF_CTRL_IF_0_DMY_BYTE_SHIFT)
+#define SF_CTRL_IF_0_ADR_BYTE_SHIFT              (17U)
+#define SF_CTRL_IF_0_ADR_BYTE_MASK               (0x7 << SF_CTRL_IF_0_ADR_BYTE_SHIFT)
+#define SF_CTRL_IF_0_CMD_BYTE_SHIFT              (20U)
+#define SF_CTRL_IF_0_CMD_BYTE_MASK               (0x7 << SF_CTRL_IF_0_CMD_BYTE_SHIFT)
+#define SF_CTRL_IF_0_DAT_RW                      BIT(23)
+#define SF_CTRL_IF_0_DAT_EN                      BIT(24)
+#define SF_CTRL_IF_0_DMY_EN                      BIT(25)
+#define SF_CTRL_IF_0_ADR_EN                      BIT(26)
+#define SF_CTRL_IF_0_CMD_EN                      BIT(27)
+#define SF_CTRL_IF_0_SPI_MODE_SHIFT              (28U)
+#define SF_CTRL_IF_0_SPI_MODE_MASK               (0x7 << SF_CTRL_IF_0_SPI_MODE_SHIFT)
+#define SF_CTRL_IF_0_QPI_MODE_EN                 BIT(31)
+
+/* 0x4 : sf_if_sahb_1 */
+#define SF_CTRL_IF_0_CMD_BUF_0_SHIFT             (0U)
+#define SF_CTRL_IF_0_CMD_BUF_0_MASK              (0xffffffffL << SF_CTRL_IF_0_CMD_BUF_0_SHIFT)
+
+/* 0x8 : sf_if_sahb_2 */
+#define SF_CTRL_IF_0_CMD_BUF_1_SHIFT             (0U)
+#define SF_CTRL_IF_0_CMD_BUF_1_MASK              (0xffffffffL << SF_CTRL_IF_0_CMD_BUF_1_SHIFT)
+
+#define SF_CTRL_IF1_SAHB_OFFSET     0x8
+#define SF_CTRL_IF2_SAHB_OFFSET     0xC8
+
+/* Register offsets */
+#define SF_CTRL_IO_DLY_0_OFFSET                  (0x0)/* if_io_dly_0 */
+#define SF_CTRL_IO_DLY_1_OFFSET                  (0x4)/* if_io_dly_1 */
+#define SF_CTRL_IO_DLY_2_OFFSET                  (0x8)/* if_io_dly_2 */
+#define SF_CTRL_IO_DLY_3_OFFSET                  (0xc)/* if_io_dly_3 */
+#define SF_CTRL_IO_DLY_4_OFFSET                  (0x10)/* if_io_dly_4 */
+
+/* 0x0 : if_io_dly_0 */
+#define SF_CTRL_CS_DLY_SEL_SHIFT                 (0U)
+#define SF_CTRL_CS_DLY_SEL_MASK                  (0x3 << SF_CTRL_CS_DLY_SEL_SHIFT)
+#define SF_CTRL_CS2_DLY_SEL_SHIFT                (2U)
+#define SF_CTRL_CS2_DLY_SEL_MASK                 (0x3 << SF_CTRL_CS2_DLY_SEL_SHIFT)
+#define SF_CTRL_CLK_OUT_DLY_SEL_SHIFT            (8U)
+#define SF_CTRL_CLK_OUT_DLY_SEL_MASK             (0x3 << SF_CTRL_CLK_OUT_DLY_SEL_SHIFT)
+#define SF_CTRL_DQS_OE_DLY_SEL_SHIFT             (26U)
+#define SF_CTRL_DQS_OE_DLY_SEL_MASK              (0x3 << SF_CTRL_DQS_OE_DLY_SEL_SHIFT)
+#define SF_CTRL_DQS_DI_DLY_SEL_SHIFT             (28U)
+#define SF_CTRL_DQS_DI_DLY_SEL_MASK              (0x3 << SF_CTRL_DQS_DI_DLY_SEL_SHIFT)
+#define SF_CTRL_DQS_DO_DLY_SEL_SHIFT             (30U)
+#define SF_CTRL_DQS_DO_DLY_SEL_MASK              (0x3 << SF_CTRL_DQS_DO_DLY_SEL_SHIFT)
+
+/* 0x4 : if_io_dly_1 */
+#define SF_CTRL_IO_0_OE_DLY_SEL_SHIFT            (0U)
+#define SF_CTRL_IO_0_OE_DLY_SEL_MASK             (0x3 << SF_CTRL_IO_0_OE_DLY_SEL_SHIFT)
+#define SF_CTRL_IO_0_DI_DLY_SEL_SHIFT            (8U)
+#define SF_CTRL_IO_0_DI_DLY_SEL_MASK             (0x3 << SF_CTRL_IO_0_DI_DLY_SEL_SHIFT)
+#define SF_CTRL_IO_0_DO_DLY_SEL_SHIFT            (16U)
+#define SF_CTRL_IO_0_DO_DLY_SEL_MASK             (0x3 << SF_CTRL_IO_0_DO_DLY_SEL_SHIFT)
+
+/* 0x8 : if_io_dly_2 */
+#define SF_CTRL_IO_1_OE_DLY_SEL_SHIFT            (0U)
+#define SF_CTRL_IO_1_OE_DLY_SEL_MASK             (0x3 << SF_CTRL_IO_1_OE_DLY_SEL_SHIFT)
+#define SF_CTRL_IO_1_DI_DLY_SEL_SHIFT            (8U)
+#define SF_CTRL_IO_1_DI_DLY_SEL_MASK             (0x3 << SF_CTRL_IO_1_DI_DLY_SEL_SHIFT)
+#define SF_CTRL_IO_1_DO_DLY_SEL_SHIFT            (16U)
+#define SF_CTRL_IO_1_DO_DLY_SEL_MASK             (0x3 << SF_CTRL_IO_1_DO_DLY_SEL_SHIFT)
+
+/* 0xc : if_io_dly_3 */
+#define SF_CTRL_IO_2_OE_DLY_SEL_SHIFT            (0U)
+#define SF_CTRL_IO_2_OE_DLY_SEL_MASK             (0x3 << SF_CTRL_IO_2_OE_DLY_SEL_SHIFT)
+#define SF_CTRL_IO_2_DI_DLY_SEL_SHIFT            (8U)
+#define SF_CTRL_IO_2_DI_DLY_SEL_MASK             (0x3 << SF_CTRL_IO_2_DI_DLY_SEL_SHIFT)
+#define SF_CTRL_IO_2_DO_DLY_SEL_SHIFT            (16U)
+#define SF_CTRL_IO_2_DO_DLY_SEL_MASK             (0x3 << SF_CTRL_IO_2_DO_DLY_SEL_SHIFT)
+
+/* 0x10 : if_io_dly_4 */
+#define SF_CTRL_IO_3_OE_DLY_SEL_SHIFT            (0U)
+#define SF_CTRL_IO_3_OE_DLY_SEL_MASK             (0x3 << SF_CTRL_IO_3_OE_DLY_SEL_SHIFT)
+#define SF_CTRL_IO_3_DI_DLY_SEL_SHIFT            (8U)
+#define SF_CTRL_IO_3_DI_DLY_SEL_MASK             (0x3 << SF_CTRL_IO_3_DI_DLY_SEL_SHIFT)
+#define SF_CTRL_IO_3_DO_DLY_SEL_SHIFT            (16U)
+#define SF_CTRL_IO_3_DO_DLY_SEL_MASK             (0x3 << SF_CTRL_IO_3_DO_DLY_SEL_SHIFT)
+
+#define SF_CTRL_IF_IO_DLY_1_OFFSET                0x30
+#define SF_CTRL_IF_IO_DLY_2_OFFSET                0x48
+#define SF_CTRL_IF_IO_DLY_3_OFFSET                0x5C
+
+/* Register offsets */
+#define SF_CTRL_SF_AES_KEY_0_OFFSET              (0x0)/* sf_aes_key_0 */
+#define SF_CTRL_SF_AES_KEY_1_OFFSET              (0x4)/* sf_aes_key_1 */
+#define SF_CTRL_SF_AES_KEY_2_OFFSET              (0x8)/* sf_aes_key_2 */
+#define SF_CTRL_SF_AES_KEY_3_OFFSET              (0xc)/* sf_aes_key_3 */
+#define SF_CTRL_SF_AES_KEY_4_OFFSET              (0x10)/* sf_aes_key_4 */
+#define SF_CTRL_SF_AES_KEY_5_OFFSET              (0x14)/* sf_aes_key_5 */
+#define SF_CTRL_SF_AES_KEY_6_OFFSET              (0x18)/* sf_aes_key_6 */
+#define SF_CTRL_SF_AES_KEY_7_OFFSET              (0x1c)/* sf_aes_key_7 */
+#define SF_CTRL_SF_AES_IV_W0_OFFSET              (0x20)/* sf_aes_iv_w0 */
+#define SF_CTRL_SF_AES_IV_W1_OFFSET              (0x24)/* sf_aes_iv_w1 */
+#define SF_CTRL_SF_AES_IV_W2_OFFSET              (0x28)/* sf_aes_iv_w2 */
+#define SF_CTRL_SF_AES_IV_W3_OFFSET              (0x2c)/* sf_aes_iv_w3 */
+#define SF_CTRL_SF_AES_START_OFFSET              (0x30)/* sf_aes_start */
+#define SF_CTRL_SF_AES_END_OFFSET                (0x34)/* sf_aes_end */
+
+/* 0x0 : sf_aes_key_0 */
+#define SF_CTRL_SF_AES_KEY_0_SHIFT               (0U)
+#define SF_CTRL_SF_AES_KEY_0_MASK                (0xffffffffL << SF_CTRL_SF_AES_KEY_0_SHIFT)
+
+/* 0x4 : sf_aes_key_1 */
+#define SF_CTRL_SF_AES_KEY_1_SHIFT               (0U)
+#define SF_CTRL_SF_AES_KEY_1_MASK                (0xffffffffL << SF_CTRL_SF_AES_KEY_1_SHIFT)
+
+/* 0x8 : sf_aes_key_2 */
+#define SF_CTRL_SF_AES_KEY_2_SHIFT               (0U)
+#define SF_CTRL_SF_AES_KEY_2_MASK                (0xffffffffL << SF_CTRL_SF_AES_KEY_2_SHIFT)
+
+/* 0xc : sf_aes_key_3 */
+#define SF_CTRL_SF_AES_KEY_3_SHIFT               (0U)
+#define SF_CTRL_SF_AES_KEY_3_MASK                (0xffffffffL << SF_CTRL_SF_AES_KEY_3_SHIFT)
+
+/* 0x10 : sf_aes_key_4 */
+#define SF_CTRL_SF_AES_KEY_4_SHIFT               (0U)
+#define SF_CTRL_SF_AES_KEY_4_MASK                (0xffffffffL << SF_CTRL_SF_AES_KEY_4_SHIFT)
+
+/* 0x14 : sf_aes_key_5 */
+#define SF_CTRL_SF_AES_KEY_5_SHIFT               (0U)
+#define SF_CTRL_SF_AES_KEY_5_MASK                (0xffffffffL << SF_CTRL_SF_AES_KEY_5_SHIFT)
+
+/* 0x18 : sf_aes_key_6 */
+#define SF_CTRL_SF_AES_KEY_6_SHIFT               (0U)
+#define SF_CTRL_SF_AES_KEY_6_MASK                (0xffffffffL << SF_CTRL_SF_AES_KEY_6_SHIFT)
+
+/* 0x1c : sf_aes_key_7 */
+#define SF_CTRL_SF_AES_KEY_7_SHIFT               (0U)
+#define SF_CTRL_SF_AES_KEY_7_MASK                (0xffffffffL << SF_CTRL_SF_AES_KEY_7_SHIFT)
+
+/* 0x20 : sf_aes_iv_w0 */
+#define SF_CTRL_SF_AES_IV_W0_SHIFT               (0U)
+#define SF_CTRL_SF_AES_IV_W0_MASK                (0xffffffffL << SF_CTRL_SF_AES_IV_W0_SHIFT)
+
+/* 0x24 : sf_aes_iv_w1 */
+#define SF_CTRL_SF_AES_IV_W1_SHIFT               (0U)
+#define SF_CTRL_SF_AES_IV_W1_MASK                (0xffffffffL << SF_CTRL_SF_AES_IV_W1_SHIFT)
+
+/* 0x28 : sf_aes_iv_w2 */
+#define SF_CTRL_SF_AES_IV_W2_SHIFT               (0U)
+#define SF_CTRL_SF_AES_IV_W2_MASK                (0xffffffffL << SF_CTRL_SF_AES_IV_W2_SHIFT)
+
+/* 0x2c : sf_aes_iv_w3 */
+#define SF_CTRL_SF_AES_IV_W3_SHIFT               (0U)
+#define SF_CTRL_SF_AES_IV_W3_MASK                (0xffffffffL << SF_CTRL_SF_AES_IV_W3_SHIFT)
+
+/* 0x30 : sf_aes_start */
+#define SF_CTRL_SF_AES_REGION_START_SHIFT        (0U)
+#define SF_CTRL_SF_AES_REGION_START_MASK         (0x7ffff << SF_CTRL_SF_AES_REGION_START_SHIFT)
+#define SF_CTRL_SF_AES_REGION_HW_KEY_EN          BIT(29)
+#define SF_CTRL_SF_AES_REGION_EN                 BIT(30)
+#define SF_CTRL_SF_AES_REGION_LOCK               BIT(31)
+
+/* 0x34 : sf_aes_end */
+#define SF_CTRL_SF_AES_REGION_END_SHIFT          (0U)
+#define SF_CTRL_SF_AES_REGION_END_MASK           (0x7ffff << SF_CTRL_SF_AES_REGION_END_SHIFT)
+
+#define SF_CTRL_AES_REGION_OFFSET                 0x200
+
+#endif /* __BFLB_FLASH_H */
diff --git a/configs/sipeed_m1s_dock_defconfig b/configs/sipeed_m1s_dock_defconfig
new file mode 100644
index 0000000000..4ba009edb4
--- /dev/null
+++ b/configs/sipeed_m1s_dock_defconfig
@@ -0,0 +1,54 @@
+CONFIG_RISCV=y
+CONFIG_TEXT_BASE=0x50000000
+CONFIG_SYS_MALLOC_LEN=0x20000
+CONFIG_NR_DRAM_BANKS=1
+CONFIG_ENV_SIZE=0x10000
+CONFIG_ENV_SECT_SIZE=0x10000
+CONFIG_DEFAULT_DEVICE_TREE="bl808-d0-ox64"
+CONFIG_DM_RESET=y
+CONFIG_SYS_LOAD_ADDR=0x50000000
+CONFIG_ENV_ADDR=0x58200000
+CONFIG_TARGET_BFLB_BL808=y
+CONFIG_ARCH_RV64I=y
+CONFIG_RISCV_SMODE=y
+CONFIG_DISTRO_DEFAULTS=y
+# CONFIG_SYS_MALLOC_CLEAR_ON_INIT is not set
+CONFIG_STACK_SIZE=0x4000
+CONFIG_FIT=y
+CONFIG_TIMESTAMP=y
+# CONFIG_FIT_FULL_CHECK is not set
+CONFIG_FIT_VERBOSE=y
+CONFIG_BOOTSTD_DEFAULTS=y
+CONFIG_BOOTMETH_SCRIPT=y
+CONFIG_DYNAMIC_SYS_CLK_FREQ=y
+CONFIG_BOOTDELAY=5
+CONFIG_BOOTCOMMAND="mmc rescan; sleep 1; mmc rescan; run distro_bootcmd"
+# CONFIG_BOOTM_NETBSD is not set
+# CONFIG_BOOTM_PLAN9 is not set
+# CONFIG_BOOTM_RTEMS is not set
+# CONFIG_BOOTM_VXWORKS is not set
+CONFIG_CMD_BOOTMENU=y
+CONFIG_CMD_CLK=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_MTD=y
+# CONFIG_OF_OMIT_DTB is not set
+CONFIG_ENV_IS_IN_FLASH=y
+CONFIG_NET_RANDOM_ETHADDR=y
+CONFIG_MMC=y
+CONFIG_MMC_BROKEN_CD=y
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_BFLB=y
+CONFIG_DM_MTD=y
+CONFIG_MTD_NOR_FLASH=y
+CONFIG_SYS_MAX_FLASH_SECT=4096
+CONFIG_USE_SYS_MAX_FLASH_BANKS=y
+CONFIG_PHYLIB=y
+CONFIG_ETHOC=y
+CONFIG_PINCTRL=y
+CONFIG_PINCONF=y
+# CONFIG_PINCONF_RECURSIVE is not set
+CONFIG_BAUDRATE=2000000
+CONFIG_SYSRESET=y
+# CONFIG_SHA256 is not set
+CONFIG_OF_LIBFDT_OVERLAY=y
-- 
2.42.0

